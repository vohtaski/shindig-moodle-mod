Index: java/social-api/src/main/java/org/apache/shindig/social/core/config/SocialApiGuiceModule.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/core/config/SocialApiGuiceModule.java	(revision 1162941)
+++ java/social-api/src/main/java/org/apache/shindig/social/core/config/SocialApiGuiceModule.java	(working copy)
@@ -38,7 +38,14 @@
 import org.apache.shindig.social.opensocial.service.MediaItemHandler;
 import org.apache.shindig.social.opensocial.service.MessageHandler;
 import org.apache.shindig.social.opensocial.service.PersonHandler;
+import org.apache.shindig.social.opensocial.service.SpaceHandler;
+import org.apache.shindig.social.opensocial.service.ApplicationHandler;
+import org.apache.shindig.social.opensocial.service.DocumentHandler;
+import org.apache.shindig.social.opensocial.service.ContextHandler;
 
+import org.apache.shindig.social.opensocial.oauth.OAuthDataStore;
+import org.apache.shindig.social.sample.oauth.SampleOAuthDataStore;
+
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import com.google.inject.TypeLiteral;
@@ -69,6 +76,8 @@
         BeanJsonConverter.class);
     bind(BeanConverter.class).annotatedWith(Names.named("shindig.bean.converter.atom")).to(
         BeanXStreamAtomConverter.class);
+    
+    bind(OAuthDataStore.class).to(SampleOAuthDataStore.class);
 
     bind(new TypeLiteral<List<AuthenticationHandler>>(){}).toProvider(
         AuthenticationHandlerProvider.class);
@@ -85,6 +94,7 @@
    */
   protected Set<Class<?>> getHandlers() {
     return ImmutableSet.<Class<?>>of(ActivityHandler.class, AppDataHandler.class,
-        PersonHandler.class, MessageHandler.class, AlbumHandler.class, MediaItemHandler.class);
+        PersonHandler.class, MessageHandler.class, AlbumHandler.class, MediaItemHandler.class, 
+        SpaceHandler.class, ApplicationHandler.class, DocumentHandler.class, ContextHandler.class);
   }
 }
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Application.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Application.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Application.java	(revision 0)
@@ -0,0 +1,460 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.model;
+
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.Exportablebean;
+//import org.apache.shindig.social.core.model.ApplicationImpl;
+
+import com.google.common.base.Functions;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.inject.ImplementedBy;
+
+import java.util.Date;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * see <a href="http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/opensocial-reference#opensocial.Application.Field">
+ * http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/opensocial-reference#opensocial.Application.Field</a>
+ * for all field meanings. All fields are represented in the js api at this time except for lastUpdated.
+ * This field is currently only in the RESTful spec.
+ *
+ */
+//@ImplementedBy(ApplicationImpl.class)
+@Exportablebean
+public interface Application {
+  /**
+   * The type of a profile url when represented as a list field.
+   */
+  String PROFILE_URL_TYPE = "profile";
+
+  /**
+   * The type of thumbnail photo types when represented as list fields.
+   */
+  String THUMBNAIL_PHOTO_TYPE = "thumbnail";
+
+  /**
+   * The display name for the application.
+   * @return the display name
+   */
+  String getDisplayName();
+
+  /**
+   * Set the display name.
+   * @param displayName the new display name.
+   */
+  void setDisplayName(String displayName);
+
+  /**
+   * The fields that represent the application object in json form.
+   */
+  public static enum Field {
+    /** the json field for appData. */
+    APP_DATA("appData"),
+    /** the json field for appType. */
+    APP_TYPE("appType"),
+    /** the json field for appUrl. */
+    APP_URL("appUrl"),
+    /** the json field for author. */
+    AUTHOR("author"),
+    /** the json field for authorEmail. */
+    AUTHOR_EMAIL("authorEmail"),
+    /** the json field for parentId. */
+    PARENT_ID("parentId"),
+    /** the json field for parentType. */
+    PARENT_TYPE("parentType"),
+    /** the json field for description. */
+    DESCRIPTION("description"),
+    /** the json field for display name. */
+    DISPLAY_NAME("displayName"), /** Needed to support the RESTful api. */
+    /** the json field for height. */
+    HEIGHT("height"),
+    /** the json field for id. */
+    ID("id"),
+    /** the json field for IM accounts. */
+    IMS("ims"),
+    /** the json field for name. */
+    NAME("name"),
+    /** the json field for screenshotUrl. */
+    SCREENSHOT_URL("screenshotUrl"),
+    /** the json field for tags. */
+    TAGS("tags"),
+    /** the json field for thumbnailUrl. */
+    THUMBNAIL_URL("thumbnailUrl"),
+    /** the json field for utcOffset. */
+    UTC_OFFSET("utcOffset");
+
+    /**
+     * a Map to convert json string to Field representations.
+     */
+
+    private static final Map<String,Field> LOOKUP = Maps.uniqueIndex(EnumSet.allOf(Field.class), 
+        Functions.toStringFunction());
+
+    /**
+     * The json field that the instance represents.
+     */
+    private final String urlString;
+
+    /**
+     * The set of all fields.
+     */
+    public static final Set<String> ALL_FIELDS = LOOKUP.keySet();
+
+    /**
+     * The set of default fields returned fields.
+     */
+    public static final Set<String> DEFAULT_FIELDS = ImmutableSet.of(
+        ID.toString(),
+        NAME.toString(),           
+        APP_URL.toString(), 
+		PARENT_ID.toString(),
+		PARENT_TYPE.toString(),
+        THUMBNAIL_URL.toString());
+
+    /**
+     * create a field base on the a json element.
+     *
+     * @param urlString the name of the element
+     */
+    private Field(String urlString) {
+      this.urlString = urlString;
+    }
+
+    /**
+     * emit the field as a json element.
+     *
+     * @return the field name
+     */
+    @Override
+    public String toString() {
+      return this.urlString;
+    }
+
+    public static Field getField(String jsonString) {
+      return LOOKUP.get(jsonString);
+    }
+
+    /**
+     * Converts from a url string (usually passed in the fields= parameter) into the
+     * corresponding field enum.
+     * @param urlString The string to translate.
+     * @return The corresponding application field.
+     */
+    public static Application.Field fromUrlString(String urlString) {
+      return LOOKUP.get(urlString);
+    }
+  }
+
+  /**
+   * Get app data for the application.
+   * 
+   * @return the app data, possibly a subset.
+   */
+  Map<String, ?> getAppData();
+  
+  /**
+   * Sets app data for the application.
+   * 
+   * @param appData the app data, possibly a subset 
+   */
+  void setAppData(Map<String, ?> appData);  
+
+
+	/**
+	 * Get addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return appUrl
+	 */
+	String getAppType();
+
+	/**
+	 * Set addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param appUrl appUrl objects
+	 */
+	void setAppType(String appType); 
+	
+	/**
+	 * Get addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return appUrl
+	 */
+	String getAppUrl();
+
+	/**
+	 * Set addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param appUrl appUrl objects
+	 */
+	void setAppUrl(String appUrl); 
+	
+	/**
+	 * Get addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return author
+	 */
+	String getAuthor();
+
+	/**
+	 * Set addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param author author objects
+	 */
+	void setAuthor(String author);	
+
+	/**
+	 * Get addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return authorEmail
+	 */
+	String getAuthorEmail();
+
+	/**
+	 * Set addresses associated with the application, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param authorEmail authorEmail objects
+	 */
+	void setAuthorEmail(String authorEmail);
+
+  /**
+   * Set A parent ID for a application/application to which this application belongs. Container support for this
+   * field is REQUIRED.
+   * @return the parentId
+   */
+  String getParentId();
+
+  /**
+   * Set A parent ID for a application/application to which this application belongs. Container support for this
+   * field is REQUIRED.
+   *
+   * @param parentId of element to which application belongs
+   */
+  void setParentId(String parentId);
+
+	/**
+	 * Set A parent TYPE to @application or @application where this application belongs. Container support for this
+	 * field is REQUIRED.
+	 * @return the parentType
+	 */
+	String getParentType();
+
+	/**
+	 * Set A parent TYPE to @application or @application where this application belongs. Container support for this
+	 * field is REQUIRED.
+	 *
+	 * @param parentType of element to which application belongs
+	 */
+	void setParentType(String parentType);  
+
+	/**
+	 * Get string description of a application, specified as a string. Container support for this field is
+	 * OPTIONAL.
+	 *
+	 * @return the application's description
+	 */
+	String getDescription();
+
+	/**
+	 * Set string description of a application, specified as a string. Container support for this field is
+	 * OPTIONAL.
+	 *
+	 * @param description the application's description 
+	 */
+	void setDescription(String description); 
+  
+  /**
+   * Get the application's Emails associated with the application.
+   * Container support for this field is OPTIONAL.
+   *
+   * @return a list of the application's emails
+   */
+  Integer getHeight();
+
+  /**
+   * Set the application's Emails associated with the application.
+   * Container support for this field is OPTIONAL.
+   *
+   * @param height a list of the application's emails
+   */
+  void setHeight(Integer height);
+
+  /**
+   * Get A string ID that can be permanently associated with this application. Container support for this
+   * field is REQUIRED.
+   *
+   * @return the permanent ID of the application
+   */
+  String getId();
+
+  /**
+   * Set A string ID that can be permanently associated with this application. Container support for this
+   * field is REQUIRED.
+   *
+   * @param id the permanent ID of the application
+   */
+  void setId(String id);
+    
+  /**
+   * Get a list of Instant messaging address for this Application. No official canonicalization rules
+   * exist for all instant messaging addresses, but Service Providers SHOULD remove all whiteapplication
+   * and convert the address to lowercase, if this is appropriate for the service this IM address is
+   * used for. Instead of the standard Canonical Values for type, this field defines the following
+   * Canonical Values to represent currently popular IM services: aim, gtalk, icq, xmpp, msn, skype,
+   * qq, and yahoo.
+   *
+   * @return A list of IM addresses
+   */
+  List<ListField> getIms();
+
+  /**
+   * Set a list of Instant messaging address for this Application. No official canonicalization rules
+   * exist for all instant messaging addresses, but Service Providers SHOULD remove all whiteapplication
+   * and convert the address to lowercase, if this is appropriate for the service this IM address is
+   * used for. Instead of the standard Canonical Values for type, this field defines the following
+   * Canonical Values to represent currently popular IM services: aim, gtalk, icq, xmpp, msn, skype,
+   * qq, and yahoo.
+   *
+   * @param ims a list ListFields representing IM addresses.
+   */
+  void setIms(List<ListField> ims);  
+
+	/**
+	 * Get the application's name Container support for this field is REQUIRED.
+	 *
+	 * @return the application's name
+	 */
+	String getName();
+
+	/**
+	 * Set the application's name Container support for this field is REQUIRED.
+	 *
+	 * @param name the application's name
+	 */
+	void setName(String name);
+
+	/**
+	 * Get the Phone numbers associated with the application.
+	 *
+	 * @return the Phone numbers associated with the application
+	 */
+  String getScreenshotUrl();
+
+	/**
+	 * Set the Phone numbers associated with the application.
+	 *
+	 * @param phoneNumbers the Phone numbers associated with the application
+	 */
+	void setScreenshotUrl(String screenshotUrl);
+  
+	/**
+   * Get arbitrary tags about the person. Container support for this field is OPTIONAL.
+   *
+   * @return arbitrary tags about the person.
+   */
+  List<String> getTags();
+
+  /**
+   * Set arbitrary tags about the person. Container support for this field is OPTIONAL.
+   *
+   * @param tags arbitrary tags about the person.
+   */
+  void setTags(List<String> tags);
+
+  /**
+   * Get the application's profile url. Container support for this field is OPTIONAL.
+   *
+   * @return the application's status, headline or shoutout
+   */
+  String getProfileUrl();
+
+  /**
+   * Set the application's profile url. Container support for this field is OPTIONAL.
+   *
+   * @param status the application's status, headline or shoutout
+   */
+  void setProfileUrl(String profileUrl);
+
+  /**
+   * Get the application's status, headline or shoutout. Container support for this field is OPTIONAL.
+   *
+   * @return the application's status, headline or shoutout
+   */
+  String getThumbnailUrl();
+
+  /**
+   * Set the application's status, headline or shoutout. Container support for this field is OPTIONAL.
+   *
+   * @param status the application's status, headline or shoutout
+   */
+  void setThumbnailUrl(String thumbnailUrl);
+
+  /**
+   * The time this application was last updated.
+   *
+   * @return the last update time
+   */
+  Date getUpdated();
+
+  /**
+   * Set the time this record was last updated.
+   *
+   * @param updated the last update time
+   */
+  void setUpdated(Date updated);
+
+  /**
+   * Get the Application's time zone, specified as the difference in minutes between Greenwich Mean Time
+   * (GMT) and the application's local time. Container support for this field is OPTIONAL.
+   *
+   * @return the Application's time zone
+   */
+  Long getUtcOffset();
+
+  /**
+   * Set the Application's time zone, specified as the difference in minutes between Greenwich Mean Time
+   * (GMT) and the application's local time. Container support for this field is OPTIONAL.
+   *
+   * @param utcOffset the Application's time zone
+   */
+  void setUtcOffset(Long utcOffset);
+
+  /**
+   * @return true if this application object represents the owner of the current page.
+   */
+  boolean getIsOwner();
+
+  /**
+   * Set the owner flag.
+   * @param isOwner the isOwnerflag
+   */
+  void setIsOwner(boolean isOwner);
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Document.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Document.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Document.java	(revision 0)
@@ -0,0 +1,460 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.model;
+
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.Exportablebean;
+//import org.apache.shindig.social.core.model.DocumentImpl;
+
+import com.google.common.base.Functions;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.inject.ImplementedBy;
+
+import java.util.Date;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * see <a href="http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/opensocial-reference#opensocial.Document.Field">
+ * http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/opensocial-reference#opensocial.Document.Field</a>
+ * for all field meanings. All fields are represented in the js api at this time except for lastUpdated.
+ * This field is currently only in the RESTful spec.
+ *
+ */
+//@ImplementedBy(DocumentImpl.class)
+@Exportablebean
+public interface Document {
+  /**
+   * The type of a profile url when represented as a list field.
+   */
+  String PROFILE_URL_TYPE = "profile";
+
+  /**
+   * The type of thumbnail photo types when represented as list fields.
+   */
+  String THUMBNAIL_PHOTO_TYPE = "thumbnail";
+
+  /**
+   * The display name for the document.
+   * @return the display name
+   */
+  String getDisplayName();
+
+  /**
+   * Set the display name.
+   * @param displayName the new display name.
+   */
+  void setDisplayName(String displayName);
+
+  /**
+   * The fields that represent the document object in json form.
+   */
+  public static enum Field {
+    /** the json field for appData. */
+    APP_DATA("appData"),                
+    /** the json field for documentType. */
+    DOCUMENT_TYPE("documentType"),
+    /** the json field for documentEntity. */
+    DOCUMENT_ENTITY("documentEntity"),
+    /** the json field for author. */
+    AUTHOR("author"),
+    /** the json field for authorEmail. */
+    AUTHOR_EMAIL("authorEmail"),
+    /** the json field for parentId. */
+    PARENT_ID("parentId"),
+    /** the json field for parentType. */
+    PARENT_TYPE("parentType"),
+    /** the json field for description. */
+    DESCRIPTION("description"),
+    /** the json field for display name. */
+    DISPLAY_NAME("displayName"), /** Needed to support the RESTful api. */
+    /** the json field for height. */
+    HEIGHT("height"),
+    /** the json field for id. */
+    ID("id"),
+    /** the json field for IM accounts. */
+    IMS("ims"),
+    /** the json field for name. */
+    NAME("name"),
+    /** the json field for screenshotUrl. */
+    SCREENSHOT_URL("screenshotUrl"),
+    /** the json field for tags. */
+    TAGS("tags"),
+    /** the json field for thumbnailUrl. */
+    THUMBNAIL_URL("thumbnailUrl"),
+    /** the json field for utcOffset. */
+    UTC_OFFSET("utcOffset");
+
+    /**
+     * a Map to convert json string to Field representations.
+     */
+
+    private static final Map<String,Field> LOOKUP = Maps.uniqueIndex(EnumSet.allOf(Field.class), 
+        Functions.toStringFunction());
+
+    /**
+     * The json field that the instance represents.
+     */
+    private final String urlString;
+
+    /**
+     * The set of all fields.
+     */
+    public static final Set<String> ALL_FIELDS = LOOKUP.keySet();
+
+    /**
+     * The set of default fields returned fields.
+     */
+    public static final Set<String> DEFAULT_FIELDS = ImmutableSet.of(
+        ID.toString(),
+        NAME.toString(),           
+        DOCUMENT_ENTITY.toString(), 
+		PARENT_ID.toString(),
+		PARENT_TYPE.toString(),
+        THUMBNAIL_URL.toString());
+
+    /**
+     * create a field base on the a json element.
+     *
+     * @param urlString the name of the element
+     */
+    private Field(String urlString) {
+      this.urlString = urlString;
+    }
+
+    /**
+     * emit the field as a json element.
+     *
+     * @return the field name
+     */
+    @Override
+    public String toString() {
+      return this.urlString;
+    }
+
+    public static Field getField(String jsonString) {
+      return LOOKUP.get(jsonString);
+    }
+
+    /**
+     * Converts from a url string (usually passed in the fields= parameter) into the
+     * corresponding field enum.
+     * @param urlString The string to translate.
+     * @return The corresponding document field.
+     */
+    public static Document.Field fromUrlString(String urlString) {
+      return LOOKUP.get(urlString);
+    }
+  }
+
+  /**
+   * Get app data for the document.
+   * 
+   * @return the app data, possibly a subset.
+   */
+  Map<String, ?> getAppData();
+  
+  /**
+   * Sets app data for the document.
+   * 
+   * @param appData the app data, possibly a subset 
+   */
+  void setAppData(Map<String, ?> appData);  
+
+
+	/**
+	 * Get addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return documentEntity
+	 */
+	String getDocumentType();
+
+	/**
+	 * Set addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param documentEntity documentEntity objects
+	 */
+	void setDocumentType(String documentType); 
+	
+	/**
+	 * Get addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return documentEntity
+	 */
+	String getDocumentEntity();
+
+	/**
+	 * Set addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param documentEntity documentEntity objects
+	 */
+	void setDocumentEntity(String documentEntity); 
+	
+	/**
+	 * Get addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return author
+	 */
+	String getAuthor();
+
+	/**
+	 * Set addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param author author objects
+	 */
+	void setAuthor(String author);	
+
+	/**
+	 * Get addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @return authorEmail
+	 */
+	String getAuthorEmail();
+
+	/**
+	 * Set addresses associated with the document, specified as an List of Address objects. Container
+	 * support for this field is OPTIONAL.
+	 *
+	 * @param authorEmail authorEmail objects
+	 */
+	void setAuthorEmail(String authorEmail);
+
+  /**
+   * Set A parent ID for a document/document to which this document belongs. Container support for this
+   * field is REQUIRED.
+   * @return the parentId
+   */
+  String getParentId();
+
+  /**
+   * Set A parent ID for a document/document to which this document belongs. Container support for this
+   * field is REQUIRED.
+   *
+   * @param parentId of element to which document belongs
+   */
+  void setParentId(String parentId);
+
+	/**
+	 * Set A parent TYPE to @document or @document where this document belongs. Container support for this
+	 * field is REQUIRED.
+	 * @return the parentType
+	 */
+	String getParentType();
+
+	/**
+	 * Set A parent TYPE to @document or @document where this document belongs. Container support for this
+	 * field is REQUIRED.
+	 *
+	 * @param parentType of element to which document belongs
+	 */
+	void setParentType(String parentType);  
+
+	/**
+	 * Get string description of a document, specified as a string. Container support for this field is
+	 * OPTIONAL.
+	 *
+	 * @return the document's description
+	 */
+	String getDescription();
+
+	/**
+	 * Set string description of a document, specified as a string. Container support for this field is
+	 * OPTIONAL.
+	 *
+	 * @param description the document's description 
+	 */
+	void setDescription(String description); 
+  
+  /**
+   * Get the document's Emails associated with the document.
+   * Container support for this field is OPTIONAL.
+   *
+   * @return a list of the document's emails
+   */
+  Integer getHeight();
+
+  /**
+   * Set the document's Emails associated with the document.
+   * Container support for this field is OPTIONAL.
+   *
+   * @param height a list of the document's emails
+   */
+  void setHeight(Integer height);
+
+  /**
+   * Get A string ID that can be permanently associated with this document. Container support for this
+   * field is REQUIRED.
+   *
+   * @return the permanent ID of the document
+   */
+  String getId();
+
+  /**
+   * Set A string ID that can be permanently associated with this document. Container support for this
+   * field is REQUIRED.
+   *
+   * @param id the permanent ID of the document
+   */
+  void setId(String id);
+    
+  /**
+   * Get a list of Instant messaging address for this Document. No official canonicalization rules
+   * exist for all instant messaging addresses, but Service Providers SHOULD remove all whitespace
+   * and convert the address to lowercase, if this is appropriate for the service this IM address is
+   * used for. Instead of the standard Canonical Values for type, this field defines the following
+   * Canonical Values to represent currently popular IM services: aim, gtalk, icq, xmpp, msn, skype,
+   * qq, and yahoo.
+   *
+   * @return A list of IM addresses
+   */
+  List<ListField> getIms();
+
+  /**
+   * Set a list of Instant messaging address for this Document. No official canonicalization rules
+   * exist for all instant messaging addresses, but Service Providers SHOULD remove all whitedocument
+   * and convert the address to lowercase, if this is appropriate for the service this IM address is
+   * used for. Instead of the standard Canonical Values for type, this field defines the following
+   * Canonical Values to represent currently popular IM services: aim, gtalk, icq, xmpp, msn, skype,
+   * qq, and yahoo.
+   *
+   * @param ims a list ListFields representing IM addresses.
+   */
+  void setIms(List<ListField> ims);  
+
+	/**
+	 * Get the document's name Container support for this field is REQUIRED.
+	 *
+	 * @return the document's name
+	 */
+	String getName();
+
+	/**
+	 * Set the document's name Container support for this field is REQUIRED.
+	 *
+	 * @param name the document's name
+	 */
+	void setName(String name);
+
+	/**
+	 * Get the Phone numbers associated with the document.
+	 *
+	 * @return the Phone numbers associated with the document
+	 */
+  String getScreenshotUrl();
+
+	/**
+	 * Set the Phone numbers associated with the document.
+	 *
+	 * @param phoneNumbers the Phone numbers associated with the document
+	 */
+	void setScreenshotUrl(String screenshotUrl);
+  
+	/**
+   * Get arbitrary tags about the person. Container support for this field is OPTIONAL.
+   *
+   * @return arbitrary tags about the person.
+   */
+  List<String> getTags();
+
+  /**
+   * Set arbitrary tags about the person. Container support for this field is OPTIONAL.
+   *
+   * @param tags arbitrary tags about the person.
+   */
+  void setTags(List<String> tags);
+
+  /**
+   * Get the document's profile url. Container support for this field is OPTIONAL.
+   *
+   * @return the application's status, headline or shoutout
+   */
+  String getProfileUrl();
+
+  /**
+   * Set the document's profile url. Container support for this field is OPTIONAL.
+   *
+   * @param status the application's status, headline or shoutout
+   */
+  void setProfileUrl(String profileUrl);
+
+  /**
+   * Get the document's status, headline or shoutout. Container support for this field is OPTIONAL.
+   *
+   * @return the document's status, headline or shoutout
+   */
+  String getThumbnailUrl();
+
+  /**
+   * Set the document's status, headline or shoutout. Container support for this field is OPTIONAL.
+   *
+   * @param status the document's status, headline or shoutout
+   */
+  void setThumbnailUrl(String thumbnailUrl);
+
+  /**
+   * The time this document was last updated.
+   *
+   * @return the last update time
+   */
+  Date getUpdated();
+
+  /**
+   * Set the time this record was last updated.
+   *
+   * @param updated the last update time
+   */
+  void setUpdated(Date updated);
+
+  /**
+   * Get the Document's time zone, specified as the difference in minutes between Greenwich Mean Time
+   * (GMT) and the document's local time. Container support for this field is OPTIONAL.
+   *
+   * @return the Document's time zone
+   */
+  Long getUtcOffset();
+
+  /**
+   * Set the Document's time zone, specified as the difference in minutes between Greenwich Mean Time
+   * (GMT) and the document's local time. Container support for this field is OPTIONAL.
+   *
+   * @param utcOffset the Document's time zone
+   */
+  void setUtcOffset(Long utcOffset);
+
+  /**
+   * @return true if this document object represents the owner of the current page.
+   */
+  boolean getIsOwner();
+
+  /**
+   * Set the owner flag.
+   * @param isOwner the isOwnerflag
+   */
+  void setIsOwner(boolean isOwner);
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Space.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Space.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/model/Space.java	(revision 0)
@@ -0,0 +1,514 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.model;
+
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.Exportablebean;
+//import org.apache.shindig.social.core.model.SpaceImpl;
+
+import com.google.common.base.Functions;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.inject.ImplementedBy;
+
+import java.util.Date;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * see <a href="http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/opensocial-reference#opensocial.Space.Field">
+ * http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/opensocial-reference#opensocial.Space.Field</a>
+ * for all field meanings. All fields are represented in the js api at this time except for lastUpdated.
+ * This field is currently only in the RESTful spec.
+ *
+ */
+//@ImplementedBy(SpaceImpl.class)
+@Exportablebean
+public interface Space {
+  /**
+   * The type of a profile url when represented as a list field.
+   */
+  String PROFILE_URL_TYPE = "profile";
+
+  /**
+   * The type of thumbnail photo types when represented as list fields.
+   */
+  String THUMBNAIL_PHOTO_TYPE = "thumbnail";
+
+  /**
+   * The display name for the space.
+   * @return the display name
+   */
+  String getDisplayName();
+
+  /**
+   * Set the display name.
+   * @param displayName the new display name.
+   */
+  void setDisplayName(String displayName);
+
+  /**
+   * The fields that represent the space object in json form.
+   */
+  public static enum Field {
+    /** the json field for addresses. */
+    ADDRESSES("addresses"),
+    /** the json field for appData. */
+    APP_DATA("appData"),
+    /** the json field for parentId. */
+    PARENT_ID("parentId"),
+    /** the json field for parentType. */
+    PARENT_TYPE("parentType"),
+    /** the json field for description. */
+    DESCRIPTION("description"),
+    /** the json field for display name. */
+    DISPLAY_NAME("displayName"), /** Needed to support the RESTful api. */
+    /** the json field for emails. */
+    EMAILS("emails"),
+    /** the json field for hasApp. */
+    HAS_APP("hasApp"),
+    /** the json field for id. */
+    ID("id"),
+    /** the json field for images. */
+    IMAGES("images"),
+    /** the json field for IM accounts. */
+    IMS("ims"),
+    /** the json field for interests. */
+    INTERESTS("interests"),
+    /** the json field for location. */
+    LOCATION("location"),
+    /** the json field for name. */
+    NAME("name"),
+    /** the json field for phoneNumbers. */
+    PHONE_NUMBERS("phoneNumbers"),
+    /** the json field for status. */
+    STATUS("status"),
+    /** the json field for thumbnailUrl. */
+    THUMBNAIL_URL("thumbnailUrl"),
+    /** the json field for urls. */
+    URLS("urls"),
+    /** the json field for utcOffset. */
+    UTC_OFFSET("utcOffset");
+
+    /**
+     * a Map to convert json string to Field representations.
+     */
+
+    private static final Map<String,Field> LOOKUP = Maps.uniqueIndex(EnumSet.allOf(Field.class), 
+        Functions.toStringFunction());
+
+    /**
+     * The json field that the instance represents.
+     */
+    private final String urlString;
+
+    /**
+     * The set of all fields.
+     */
+    public static final Set<String> ALL_FIELDS = LOOKUP.keySet();
+
+    /**
+     * The set of default fields returned fields.
+     */
+    public static final Set<String> DEFAULT_FIELDS = ImmutableSet.of(
+        ID.toString(),
+        NAME.toString(),           
+        DESCRIPTION.toString(), 
+		PARENT_ID.toString(),
+		PARENT_TYPE.toString(),
+        THUMBNAIL_URL.toString());
+
+    /**
+     * create a field base on the a json element.
+     *
+     * @param urlString the name of the element
+     */
+    private Field(String urlString) {
+      this.urlString = urlString;
+    }
+
+    /**
+     * emit the field as a json element.
+     *
+     * @return the field name
+     */
+    @Override
+    public String toString() {
+      return this.urlString;
+    }
+
+    public static Field getField(String jsonString) {
+      return LOOKUP.get(jsonString);
+    }
+
+    /**
+     * Converts from a url string (usually passed in the fields= parameter) into the
+     * corresponding field enum.
+     * @param urlString The string to translate.
+     * @return The corresponding space field.
+     */
+    public static Space.Field fromUrlString(String urlString) {
+      return LOOKUP.get(urlString);
+    }
+  }
+
+  /**
+   * Get addresses associated with the space, specified as an List of Address objects. Container
+   * support for this field is OPTIONAL.
+   *
+   * @return a List of address objects
+   */
+  List<Address> getAddresses();
+
+  /**
+   * Set addresses associated with the space, specified as an List of Address objects. Container
+   * support for this field is OPTIONAL.
+   *
+   * @param addresses a list of address objects
+   */
+  void setAddresses(List<Address> addresses);
+
+
+  /**
+   * Get app data for the space.
+   * 
+   * @return the app data, possibly a subset.
+   */
+  Map<String, ?> getAppData();
+  
+  /**
+   * Sets app data for the space.
+   * 
+   * @param appData the app data, possibly a subset 
+   */
+  void setAppData(Map<String, ?> appData);
+
+  /**
+   * Set A parent ID for a space/space to which this space belongs. Container support for this
+   * field is REQUIRED.
+   * @return the parentId
+   */
+  String getParentId();
+
+  /**
+   * Set A parent ID for a space/space to which this space belongs. Container support for this
+   * field is REQUIRED.
+   *
+   * @param parentId of element to which space belongs
+   */
+  void setParentId(String parentId);
+
+	/**
+	 * Set A parent TYPE to @space or @space where this space belongs. Container support for this
+	 * field is REQUIRED.
+	 * @return the parentType
+	 */
+	String getParentType();
+
+	/**
+	 * Set A parent TYPE to @space or @space where this space belongs. Container support for this
+	 * field is REQUIRED.
+	 *
+	 * @param parentType of element to which space belongs
+	 */
+	void setParentType(String parentType);  
+
+	/**
+	 * Get string description of a space, specified as a string. Container support for this field is
+	 * OPTIONAL.
+	 *
+	 * @return the space's description
+	 */
+	String getDescription();
+
+	/**
+	 * Set string description of a space, specified as a string. Container support for this field is
+	 * OPTIONAL.
+	 *
+	 * @param description the space's description 
+	 */
+	void setDescription(String description); 
+  
+  /**
+   * Get the space's Emails associated with the space.
+   * Container support for this field is OPTIONAL.
+   *
+   * @return a list of the space's emails
+   */
+  List<ListField> getEmails();
+
+  /**
+   * Set the space's Emails associated with the space.
+   * Container support for this field is OPTIONAL.
+   *
+   * @param emails a list of the space's emails
+   */
+  void setEmails(List<ListField> emails);
+
+  /**
+   * Get if the space has used the current app. Container support for this field is OPTIONAL.
+   * Has app needs to take account of the parent of the application that is performing the
+   * query on this space object.
+   * @return true the current app has been used
+   */
+  Boolean getHasApp();
+
+  /**
+   * Set if the space has used the current app. Container support for this field is OPTIONAL.
+   *
+   * @param hasApp set true the current app has been used
+   */
+  void setHasApp(Boolean hasApp);
+
+  /**
+   * Get A string ID that can be permanently associated with this space. Container support for this
+   * field is REQUIRED.
+   *
+   * @return the permanent ID of the space
+   */
+  String getId();
+
+  /**
+   * Set A string ID that can be permanently associated with this space. Container support for this
+   * field is REQUIRED.
+   *
+   * @param id the permanent ID of the space
+   */
+  void setId(String id);
+    
+	/**
+	 * URL of an image for this space. The value SHOULD be a canonicalized URL, and MUST point to an
+	 * actual image file (e.g. a GIF, JPEG, or PNG image file) rather than to a web page containing an
+	 * image. Service Providers MAY return the same image at different sizes, though it is recognized
+	 * that no standard for describing images of various sizes currently exists. Note that this field
+	 * SHOULD NOT be used to send down arbitrary photos taken by this space, but specifically profile
+	 * photos of the contact suitable for display when describing the contact.
+	 *
+	 * @return a list of Images
+	 */
+	List<ListField> getImages();
+
+	/**
+	 * Set a list of Images for the space.
+	 * @see Space#getImages()
+	 *
+	 * @param images a list of images.
+	 */
+	void setImages(List<ListField> images); 
+
+  /**
+   * Get a list of Instant messaging address for this Space. No official canonicalization rules
+   * exist for all instant messaging addresses, but Service Providers SHOULD remove all whitespace
+   * and convert the address to lowercase, if this is appropriate for the service this IM address is
+   * used for. Instead of the standard Canonical Values for type, this field defines the following
+   * Canonical Values to represent currently popular IM services: aim, gtalk, icq, xmpp, msn, skype,
+   * qq, and yahoo.
+   *
+   * @return A list of IM addresses
+   */
+  List<ListField> getIms();
+
+  /**
+   * Set a list of Instant messaging address for this Space. No official canonicalization rules
+   * exist for all instant messaging addresses, but Service Providers SHOULD remove all whitespace
+   * and convert the address to lowercase, if this is appropriate for the service this IM address is
+   * used for. Instead of the standard Canonical Values for type, this field defines the following
+   * Canonical Values to represent currently popular IM services: aim, gtalk, icq, xmpp, msn, skype,
+   * qq, and yahoo.
+   *
+   * @param ims a list ListFields representing IM addresses.
+   */
+  void setIms(List<ListField> ims);  
+
+  /**
+   * Get the space's interests, hobbies or passions, specified as an List of strings. Container
+   * support for this field is OPTIONAL.
+   *
+   * @return the space's interests, hobbies or passions
+   */
+  List<String> getInterests();
+
+  /**
+   * Set the space's interests, hobbies or passions, specified as an List of strings. Container
+   * support for this field is OPTIONAL.
+   *
+   * @param interests the space's interests, hobbies or passions
+   */
+  void setInterests(List<String> interests);
+
+  /**
+   * Get the Space's favorite jobs, or job interests and skills, specified as a string. Container
+   * support for this field is OPTIONAL
+   *
+   * @return the Space's favorite jobs, or job interests and skills
+   */
+  String getLocation();
+
+  /**
+   * Set the Space's favorite jobs, or job interests and skills, specified as a string. Container
+   * support for this field is OPTIONAL
+   *
+   * @param location the Space's favorite jobs, or job interests and skills
+   */
+  void setLocation(String location);  
+
+	/**
+	 * Get the space's name Container support for this field is REQUIRED.
+	 *
+	 * @return the space's name
+	 */
+	String getName();
+
+	/**
+	 * Set the space's name Container support for this field is REQUIRED.
+	 *
+	 * @param name the space's name
+	 */
+	void setName(String name);
+
+	/**
+	 * Get the Phone numbers associated with the space.
+	 *
+	 * @return the Phone numbers associated with the space
+	 */
+	List<ListField> getPhoneNumbers();
+
+	/**
+	 * Set the Phone numbers associated with the space.
+	 *
+	 * @param phoneNumbers the Phone numbers associated with the space
+	 */
+	void setPhoneNumbers(List<ListField> phoneNumbers);
+
+	/**
+	 * Get the space's status, headline or shoutout. Container support for this field is OPTIONAL.
+	 *
+	 * @return the space's status, headline or shoutout
+	 */
+	String getStatus();
+
+	/**
+	 * Set the space's status, headline or shoutout. Container support for this field is OPTIONAL.
+	 *
+	 * @param status the space's status, headline or shoutout
+	 */
+	void setStatus(String status);
+
+  /**
+   * The time this space was last updated.
+   *
+   * @return the last update time
+   */
+  Date getUpdated();
+
+  /**
+   * Set the time this record was last updated.
+   *
+   * @param updated the last update time
+   */
+  void setUpdated(Date updated);
+
+  /**
+   * Get the Space's time zone, specified as the difference in minutes between Greenwich Mean Time
+   * (GMT) and the space's local time. Container support for this field is OPTIONAL.
+   *
+   * @return the Space's time zone
+   */
+  Long getUtcOffset();
+
+  /**
+   * Set the Space's time zone, specified as the difference in minutes between Greenwich Mean Time
+   * (GMT) and the space's local time. Container support for this field is OPTIONAL.
+   *
+   * @param utcOffset the Space's time zone
+   */
+  void setUtcOffset(Long utcOffset);
+
+  /**
+   * Get the URLs related to the space, their webpages, or feeds Container support for this field
+   * is OPTIONAL.
+   *
+   * @return the URLs related to the space, their webpages, or feeds
+   */
+  List<Url> getUrls();
+
+  /**
+   * Set the URLs related to the space, their webpages, or feeds Container support for this field
+   * is OPTIONAL.
+   *
+   * @param urls the URLs related to the space, their webpages, or feeds
+   */
+  void setUrls(List<Url> urls);
+
+  /**
+   * @return true if this space object represents the owner of the current page.
+   */
+  boolean getIsOwner();
+
+  /**
+   * Set the owner flag.
+   * @param isOwner the isOwnerflag
+   */
+  void setIsOwner(boolean isOwner);
+
+  // Proxied fields
+
+  /**
+   * Get the space's profile URL. This URL must be fully qualified. Relative URLs will not work in
+   * gadgets. This field MUST be stored in the urls list with a type of "profile".
+   *
+   * Container support for this field is OPTIONAL.
+   *
+   * @return the space's profile URL
+   */
+  String getProfileUrl();
+
+  /**
+   * Set the space's profile URL. This URL must be fully qualified. Relative URLs will not work in
+   * gadgets. This field MUST be stored in the urls list with a type of "profile".
+   *
+   * Container support for this field is OPTIONAL.
+   *
+   * @param profileUrl the space's profile URL
+   */
+  void setProfileUrl(String profileUrl);
+
+  /**
+   * Get the space's photo thumbnail URL, specified as a string. This URL must be fully qualified.
+   * Relative URLs will not work in gadgets.
+   * This field MUST be stored in the photos list with a type of "thumbnail".
+   *
+   * Container support for this field is OPTIONAL.
+   *
+   * @return the space's photo thumbnail URL
+   */
+  String getThumbnailUrl();
+
+  /**
+   * Set the space's photo thumbnail URL, specified as a string. This URL must be fully qualified.
+   * Relative URLs will not work in gadgets.
+   * This field MUST be stored in the photos list with a type of "thumbnail".
+   *
+   * Container support for this field is OPTIONAL.
+   *
+   * @param thumbnailUrl the space's photo thumbnail URL
+   */
+  void setThumbnailUrl(String thumbnailUrl);
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/ApplicationHandler.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/ApplicationHandler.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/ApplicationHandler.java	(revision 0)
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.service;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.FutureUtil;
+import org.apache.shindig.config.ContainerConfig;
+import org.apache.shindig.protocol.HandlerPreconditions;
+import org.apache.shindig.protocol.Operation;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RequestItem;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.protocol.Service;
+import org.apache.shindig.social.opensocial.model.Application;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.ApplicationId;
+import org.apache.shindig.social.opensocial.spi.ApplicationService;
+import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.Context;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
+import com.google.inject.Inject;
+
+/**
+ * RPC/REST handler for all /applications requests
+ */
+@Service(name = "applications", path = "/{contextId}+/{contextType}")
+public class ApplicationHandler {
+  private final ApplicationService applicationService;
+  private final ContainerConfig config;
+
+  @Inject
+  public ApplicationHandler(ApplicationService applicationService, ContainerConfig config) {
+    this.applicationService = applicationService;
+    this.config = config;
+  }
+
+  /**
+   * Allowed end-points /applications/{contextId}/{contextType} /applications/{applicationId}+ 
+   *
+   * examples: /applications/john.doe/@person /applications/tex.group/@space /applications/mywidget
+   */
+  @Operation(httpMethods = "GET")
+  public Future<?> get(SocialRequestItem request) throws ProtocolException {
+    Set<String> fields = request.getFields(Application.Field.DEFAULT_FIELDS);
+    Set<String> contextIds = request.getContextIds();
+    String contextType = request.getContextType();
+
+    // Preconditions
+    HandlerPreconditions.requireNotEmpty(contextIds, "No contextId is specified");
+    
+    CollectionOptions options = new CollectionOptions(request);
+    if(contextType == null){
+    	// when contextType is not specified, get list of applications specified by ids
+    	if(contextIds.size() == 1){
+    		return applicationService.getApplication(new ApplicationId(contextIds.iterator().next()), fields, request.getToken());
+    	}else{
+    	    ImmutableSet.Builder<ApplicationId> ids = ImmutableSet.builder();
+    	    for (String id : contextIds) {
+    	    	ids.add(new ApplicationId(id));
+    	    }
+    	    Set<ApplicationId> applicationIds = ids.build();
+    		
+    		return applicationService.getApplications(applicationIds, options, fields, request.getToken());
+    	}
+    }else{
+    	// contextType is specified, get a list of applications for this context
+    	if(contextIds.size() == 1){
+    		Context context = new Context(contextIds.iterator().next(),contextType);
+    		return applicationService.getApplicationsForContext(context, options, fields, request.getToken());
+    	}else{
+    		throw new IllegalArgumentException("Cannot fetch applications for multiple contexts");
+    	}
+    }
+    
+  }
+
+  @Operation(httpMethods = "GET", path="/@supportedFields")
+  public List<Object> supportedFields(RequestItem request) {
+    // TODO: Would be nice if name in config matched name of service.
+    String container = Objects.firstNonNull(request.getToken().getContainer(), "default");
+    return config.getList(container,
+        "${Cur['gadgets.features'].opensocial.supportedFields.application}");
+  }
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/SocialRequestItem.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/SocialRequestItem.java	(revision 1162941)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/SocialRequestItem.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.shindig.social.opensocial.spi.GroupId;
 import org.apache.shindig.social.opensocial.spi.PersonService;
 import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.Context;
 import org.json.JSONObject;
 
 import com.google.common.collect.ImmutableSet;
@@ -42,6 +43,9 @@
   private static final String USER_ID = "userId";
   private static final String GROUP_ID = "groupId";
 
+  private static final String CONTEXT_ID = "contextId";
+  private static final String CONTEXT_TYPE = "contextType";
+
   public SocialRequestItem(Map<String, String[]> parameters, 
       SecurityToken token, BeanConverter converter, BeanJsonConverter jsonConverter) {
     super(parameters, token, converter, jsonConverter);
@@ -65,7 +69,20 @@
     }
     return userIds.build();
   }
+  
+  public Set<String> getContextIds() {
+	  List<String> ids = getListParameter(CONTEXT_ID);
 
+	  ImmutableSet.Builder<String> contextIds = ImmutableSet.builder();
+	  for (String id : ids) {
+		  contextIds.add(id);
+	  }
+	  return contextIds.build();
+  }
+  public String getContextType() {
+	  return getParameter(CONTEXT_TYPE);
+  }
+
   public GroupId getGroup() {
     return GroupId.fromJson(getParameter(GROUP_ID, "@self"));
   }
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/ContextHandler.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/ContextHandler.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/ContextHandler.java	(revision 0)
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.service;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.FutureUtil;
+import org.apache.shindig.common.util.ImmediateFuture;
+import org.apache.shindig.config.ContainerConfig;
+import org.apache.shindig.protocol.HandlerPreconditions;
+import org.apache.shindig.protocol.Operation;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RequestItem;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.protocol.Service;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.Context;
+import org.apache.shindig.social.opensocial.spi.ContextService;
+import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.Context;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
+import com.google.inject.Inject;
+
+/**
+ * RPC/REST handler for all /contexts requests
+ */
+@Service(name = "context", path = "")
+public class ContextHandler {
+  private final ContextService contextService;
+  private final ContainerConfig config;
+
+  @Inject
+  public ContextHandler(ContextService contextService, ContainerConfig config) {
+    this.contextService = contextService;
+    this.config = config;
+  }
+
+  /**
+   * Allowed end-points /contexts/{contextId}/{contextType} /contexts/{contextId}+ 
+   *
+   * examples: /contexts/john.doe/@person /contexts/tex.group/@context /contexts/tex.group
+   */
+  @Operation(httpMethods = "GET")
+  public Future<?> get(SocialRequestItem request) throws ProtocolException {
+  
+    String owner = request.getToken().getOwnerId();
+    String id = owner;
+    String type = "@person";
+    if (owner.startsWith("s_")) { // for spaces
+      type = "@space";
+      id = owner.replaceFirst("s_","");;      
+    }
+    
+    Context context = new Context(id,type);
+    
+    return ImmediateFuture.newInstance(context);
+
+    // Preconditions
+    // 
+    
+  }
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/SpaceHandler.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/SpaceHandler.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/SpaceHandler.java	(revision 0)
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.service;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.FutureUtil;
+import org.apache.shindig.config.ContainerConfig;
+import org.apache.shindig.protocol.HandlerPreconditions;
+import org.apache.shindig.protocol.Operation;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RequestItem;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.protocol.Service;
+import org.apache.shindig.social.opensocial.model.Space;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.SpaceId;
+import org.apache.shindig.social.opensocial.spi.SpaceService;
+import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.Context;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
+import com.google.inject.Inject;
+
+/**
+ * RPC/REST handler for all /spaces requests
+ */
+@Service(name = "spaces", path = "/{contextId}+/{contextType}")
+public class SpaceHandler {
+  private final SpaceService spaceService;
+  private final ContainerConfig config;
+
+  @Inject
+  public SpaceHandler(SpaceService spaceService, ContainerConfig config) {
+    this.spaceService = spaceService;
+    this.config = config;
+  }
+
+  /**
+   * Allowed end-points /spaces/{contextId}/{contextType} /spaces/{spaceId}+ 
+   *
+   * examples: /spaces/john.doe/@person /spaces/tex.group/@space /spaces/tex.group
+   */
+  @Operation(httpMethods = "GET")
+  public Future<?> get(SocialRequestItem request) throws ProtocolException {
+    Set<String> fields = request.getFields(Space.Field.DEFAULT_FIELDS);
+    Set<String> contextIds = request.getContextIds();
+    String contextType = request.getContextType();
+
+    // Preconditions
+    HandlerPreconditions.requireNotEmpty(contextIds, "No contextId is specified");
+    
+    CollectionOptions options = new CollectionOptions(request);
+    if(contextType == null){
+    	// when contextType is not specified, get list of spaces specified by ids
+    	if(contextIds.size() == 1){
+    		return spaceService.getSpace(new SpaceId(contextIds.iterator().next()), fields, request.getToken());
+    	}else{
+    	    ImmutableSet.Builder<SpaceId> ids = ImmutableSet.builder();
+    	    for (String id : contextIds) {
+    	    	ids.add(new SpaceId(id));
+    	    }
+    	    Set<SpaceId> spaceIds = ids.build();
+    		
+    		return spaceService.getSpaces(spaceIds, options, fields, request.getToken());
+    	}
+    }else{
+    	// contextType is specified, get a list of spaces for this context
+    	if(contextIds.size() == 1){
+    		Context context = new Context(contextIds.iterator().next(),contextType);
+    		return spaceService.getSpacesForContext(context, options, fields, request.getToken());
+    	}else{
+    		throw new IllegalArgumentException("Cannot fetch spaces for multiple contexts");
+    	}
+    }
+    
+  }
+
+  @Operation(httpMethods = "GET", path="/@supportedFields")
+  public List<Object> supportedFields(RequestItem request) {
+    // TODO: Would be nice if name in config matched name of service.
+    String container = Objects.firstNonNull(request.getToken().getContainer(), "default");
+    return config.getList(container,
+        "${Cur['gadgets.features'].opensocial.supportedFields.space}");
+  }
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/DocumentHandler.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/DocumentHandler.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/service/DocumentHandler.java	(revision 0)
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.service;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.FutureUtil;
+import org.apache.shindig.config.ContainerConfig;
+import org.apache.shindig.protocol.HandlerPreconditions;
+import org.apache.shindig.protocol.Operation;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RequestItem;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.protocol.Service;
+import org.apache.shindig.social.opensocial.model.Document;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.DocumentId;
+import org.apache.shindig.social.opensocial.spi.DocumentService;
+import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.Context;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
+import com.google.inject.Inject;
+
+/**
+ * RPC/REST handler for all /documents requests
+ */
+@Service(name = "documents", path = "/{contextId}+/{contextType}")
+public class DocumentHandler {
+  private final DocumentService documentService;
+  private final ContainerConfig config;
+
+  @Inject
+  public DocumentHandler(DocumentService documentService, ContainerConfig config) {
+    this.documentService = documentService;
+    this.config = config;
+  }
+
+  /**
+   * Allowed end-points /documents/{contextId}/{contextType} /documents/{documentId}+ 
+   *
+   * examples: /documents/john.doe/@person /documents/tex.group/@space /documents/mywidget
+   */
+  @Operation(httpMethods = "GET")
+  public Future<?> get(SocialRequestItem request) throws ProtocolException {
+    Set<String> fields = request.getFields(Document.Field.DEFAULT_FIELDS);
+    Set<String> contextIds = request.getContextIds();
+    String contextType = request.getContextType();
+
+    // Preconditions
+    HandlerPreconditions.requireNotEmpty(contextIds, "No contextId is specified");
+    
+    CollectionOptions options = new CollectionOptions(request);
+    if(contextType == null){
+    	// when contextType is not specified, get list of documents specified by ids
+    	if(contextIds.size() == 1){
+    		return documentService.getDocument(new DocumentId(contextIds.iterator().next()), fields, request.getToken());
+    	}else{
+    	    ImmutableSet.Builder<DocumentId> ids = ImmutableSet.builder();
+    	    for (String id : contextIds) {
+    	    	ids.add(new DocumentId(id));
+    	    }
+    	    Set<DocumentId> documentIds = ids.build();
+    		
+    		return documentService.getDocuments(documentIds, options, fields, request.getToken());
+    	}
+    }else{
+    	// contextType is specified, get a list of documents for this context
+    	if(contextIds.size() == 1){
+    		Context context = new Context(contextIds.iterator().next(),contextType);
+    		return documentService.getDocumentsForContext(context, options, fields, request.getToken());
+    	}else{
+    		throw new IllegalArgumentException("Cannot fetch documents for multiple contexts");
+    	}
+    }
+    
+  }
+
+  @Operation(httpMethods = "GET", path="/@supportedFields")
+  public List<Object> supportedFields(RequestItem request) {
+    // TODO: Would be nice if name in config matched name of service.
+    String container = Objects.firstNonNull(request.getToken().getContainer(), "default");
+    return config.getList(container,
+        "${Cur['gadgets.features'].opensocial.supportedFields.document}");
+  }
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/DocumentService.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/DocumentService.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/DocumentService.java	(revision 0)
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.model.Document;
+
+import java.util.Set;
+import java.util.concurrent.Future;
+
+/**
+ * Interface that defines how shindig gathers spaces information.
+ */
+public interface DocumentService {
+
+  /**
+   * When used will sort people by the container's definition of top friends. Note that both the
+   * sort order and the filter are required to deliver a topFriends response. The PersonService
+   * implementation should take this into account when delivering a topFriends response.
+   */
+  public static String TOP_FRIENDS_SORT = "topFriends";
+  /**
+   * Retrieves only the user's top friends. The meaning of top and how many top is is defined by the
+   * PersonService implementation.
+   */
+  public static String TOP_FRIENDS_FILTER = "topFriends";
+  /**
+   * Retrieves all friends with any data for this document.
+   * TODO: how is this document defined
+   */
+  public static String HAS_APP_FILTER = "hasApp";
+  /**
+   * Retrieves all friends. (ie no filter)
+   */
+  public static String ALL_FILTER = "all";
+  /**
+   * Will filter the people requested by checking if they are friends with the given idSpec. The
+   * filter value will be set to the userId of the target friend.
+   */
+  public static String IS_WITH_FRIENDS_FILTER = "isFriendsWith";
+
+  /**
+   * Returns a list of documents for the context.
+   *
+   * @param contexts A context for which documents to be returned
+   * @param collectionOptions How to filter, sort and paginate the collection being fetched
+   * @param fields The profile details to fetch. Empty set implies all
+   * @param token The gadget token @return a list of people.
+   * @return Future that returns a RestfulCollection of Document
+   */
+  Future<RestfulCollection<Document>> getDocumentsForContext(Context context,
+      CollectionOptions collectionOptions, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+  
+  /**
+   * Returns a list of documents that correspond to the passed in documentsIds.
+   *
+   * @param documentsIds A set of document ids
+   * @param collectionOptions How to filter, sort and paginate the collection being fetched
+   * @param fields The profile details to fetch. Empty set implies all
+   * @param token The gadget token @return a list of people.
+   * @return Future that returns a RestfulCollection of Document
+   */
+  Future<RestfulCollection<Document>> getDocuments(Set<DocumentId> documentIds,
+      CollectionOptions collectionOptions, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+  
+  /**
+   * Returns an document that corresponds to the passed in document id.
+   *
+   * @param id The document id for which document info to be fetched.
+   * @param fields The fields to fetch.
+   * @param token The gadget token
+   * @return an document.
+   */
+  Future<Document> getDocument(DocumentId documentId, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ContextService.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ContextService.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ContextService.java	(revision 0)
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.config.ContainerConfig;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.model.Space;
+
+import java.util.Set;
+import java.util.concurrent.Future;
+
+/**
+ * Interface that defines how shindig gathers spaces information.
+ */
+public class ContextService {
+	  public ContextService() {
+
+	  }
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/SpaceId.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/SpaceId.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/SpaceId.java	(revision 0)
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.base.Objects;
+
+import java.util.Map;
+
+/**
+ * Data structure representing a spaceid
+ */
+public class SpaceId {
+
+
+  private String spaceId;
+
+  public SpaceId(String spaceId) {
+    this.spaceId = spaceId;
+  }
+
+  public String getSpaceId() {
+    return spaceId;
+  }
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/SpaceService.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/SpaceService.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/SpaceService.java	(revision 0)
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.model.Space;
+
+import java.util.Set;
+import java.util.concurrent.Future;
+
+/**
+ * Interface that defines how shindig gathers spaces information.
+ */
+public interface SpaceService {
+
+  /**
+   * When used will sort people by the container's definition of top friends. Note that both the
+   * sort order and the filter are required to deliver a topFriends response. The PersonService
+   * implementation should take this into account when delivering a topFriends response.
+   */
+  public static String TOP_FRIENDS_SORT = "topFriends";
+  /**
+   * Retrieves only the user's top friends. The meaning of top and how many top is is defined by the
+   * PersonService implementation.
+   */
+  public static String TOP_FRIENDS_FILTER = "topFriends";
+  /**
+   * Retrieves all friends with any data for this application.
+   * TODO: how is this application defined
+   */
+  public static String HAS_APP_FILTER = "hasApp";
+  /**
+   * Retrieves all friends. (ie no filter)
+   */
+  public static String ALL_FILTER = "all";
+  /**
+   * Will filter the people requested by checking if they are friends with the given idSpec. The
+   * filter value will be set to the userId of the target friend.
+   */
+  public static String IS_WITH_FRIENDS_FILTER = "isFriendsWith";
+
+  /**
+   * Returns a list of space for the context.
+   *
+   * @param contexts A context for which spaces to be returned
+   * @param collectionOptions How to filter, sort and paginate the collection being fetched
+   * @param fields The profile details to fetch. Empty set implies all
+   * @param token The gadget token @return a list of people.
+   * @return Future that returns a RestfulCollection of Space
+   */
+  Future<RestfulCollection<Space>> getSpacesForContext(Context context,
+      CollectionOptions collectionOptions, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+  
+  /**
+   * Returns a list of spaces that correspond to the passed in spacesIds.
+   *
+   * @param spaceIds A set of space ids
+   * @param collectionOptions How to filter, sort and paginate the collection being fetched
+   * @param fields The profile details to fetch. Empty set implies all
+   * @param token The gadget token @return a list of people.
+   * @return Future that returns a RestfulCollection of Space
+   */
+  Future<RestfulCollection<Space>> getSpaces(Set<SpaceId> spaceIds,
+      CollectionOptions collectionOptions, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+  
+  /**
+   * Returns a space that corresponds to the passed in space id.
+   *
+   * @param id The space id for which space info to be fetched.
+   * @param fields The fields to fetch.
+   * @param token The gadget token
+   * @return a space.
+   */
+  Future<Space> getSpace(SpaceId spaceId, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ApplicationId.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ApplicationId.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ApplicationId.java	(revision 0)
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.base.Objects;
+
+import java.util.Map;
+
+/**
+ * Data structure representing a applicationid
+ */
+public class ApplicationId {
+
+
+  private String applicationId;
+
+  public ApplicationId(String applicationId) {
+    this.applicationId = applicationId;
+  }
+
+  public String getApplicationId() {
+    return applicationId;
+  }
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/Context.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/Context.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/Context.java	(revision 0)
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.social.opensocial.spi.UserId.Type;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.base.Objects;
+
+import java.util.Map;
+
+/**
+ * Data structure representing a context
+ */
+public class Context {
+
+  private String contextId;
+  private String contextType;
+
+  public Context(String contextId, String contextType) {
+    this.contextId = contextId;
+    this.contextType = contextType;
+  }
+
+  public String getContextId() {
+    return contextId;
+  }
+
+  public String getContextType() {
+    return contextType;
+  }
+
+  public static UserId fromJson(String jsonId) {
+	  Type idSpecEnum = Type.jsonValueOf(jsonId);
+	  if (idSpecEnum != null) {
+		  return new UserId(idSpecEnum, null);
+	  }
+
+	  return new UserId(Type.userId, jsonId);
+  }
+
+
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ApplicationService.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ApplicationService.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/ApplicationService.java	(revision 0)
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.model.Application;
+
+import java.util.Set;
+import java.util.concurrent.Future;
+
+/**
+ * Interface that defines how shindig gathers spaces information.
+ */
+public interface ApplicationService {
+
+  /**
+   * When used will sort people by the container's definition of top friends. Note that both the
+   * sort order and the filter are required to deliver a topFriends response. The PersonService
+   * implementation should take this into account when delivering a topFriends response.
+   */
+  public static String TOP_FRIENDS_SORT = "topFriends";
+  /**
+   * Retrieves only the user's top friends. The meaning of top and how many top is is defined by the
+   * PersonService implementation.
+   */
+  public static String TOP_FRIENDS_FILTER = "topFriends";
+  /**
+   * Retrieves all friends with any data for this application.
+   * TODO: how is this application defined
+   */
+  public static String HAS_APP_FILTER = "hasApp";
+  /**
+   * Retrieves all friends. (ie no filter)
+   */
+  public static String ALL_FILTER = "all";
+  /**
+   * Will filter the people requested by checking if they are friends with the given idSpec. The
+   * filter value will be set to the userId of the target friend.
+   */
+  public static String IS_WITH_FRIENDS_FILTER = "isFriendsWith";
+
+  /**
+   * Returns a list of applications for the context.
+   *
+   * @param contexts A context for which applications to be returned
+   * @param collectionOptions How to filter, sort and paginate the collection being fetched
+   * @param fields The profile details to fetch. Empty set implies all
+   * @param token The gadget token @return a list of people.
+   * @return Future that returns a RestfulCollection of Application
+   */
+  Future<RestfulCollection<Application>> getApplicationsForContext(Context context,
+      CollectionOptions collectionOptions, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+  
+  /**
+   * Returns a list of applications that correspond to the passed in applicationsIds.
+   *
+   * @param applicationsIds A set of application ids
+   * @param collectionOptions How to filter, sort and paginate the collection being fetched
+   * @param fields The profile details to fetch. Empty set implies all
+   * @param token The gadget token @return a list of people.
+   * @return Future that returns a RestfulCollection of Application
+   */
+  Future<RestfulCollection<Application>> getApplications(Set<ApplicationId> applicationIds,
+      CollectionOptions collectionOptions, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+  
+  /**
+   * Returns an application that corresponds to the passed in application id.
+   *
+   * @param id The application id for which application info to be fetched.
+   * @param fields The fields to fetch.
+   * @param token The gadget token
+   * @return an application.
+   */
+  Future<Application> getApplication(ApplicationId applicationId, Set<String> fields, SecurityToken token)
+      throws ProtocolException;
+}
Index: java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/DocumentId.java
===================================================================
--- java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/DocumentId.java	(revision 0)
+++ java/social-api/src/main/java/org/apache/shindig/social/opensocial/spi/DocumentId.java	(revision 0)
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.spi;
+
+import org.apache.shindig.auth.SecurityToken;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.base.Objects;
+
+import java.util.Map;
+
+/**
+ * Data structure representing a documentid
+ */
+public class DocumentId {
+
+
+  private String documentId;
+
+  public DocumentId(String documentId) {
+    this.documentId = documentId;
+  }
+
+  public String getDocumentId() {
+    return documentId;
+  }
+
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/SpaceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/SpaceDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/SpaceDb.java	(revision 0)
@@ -0,0 +1,536 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa;
+
+import static javax.persistence.CascadeType.ALL;
+import static javax.persistence.CascadeType.MERGE;
+import static javax.persistence.CascadeType.PERSIST;
+import static javax.persistence.CascadeType.REFRESH;
+import static javax.persistence.GenerationType.IDENTITY;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
+import org.apache.shindig.social.opensocial.jpa.api.DbObject;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.FilterOperation;
+import org.apache.shindig.social.opensocial.model.Account;
+import org.apache.shindig.social.opensocial.model.Address;
+import org.apache.shindig.social.opensocial.model.BodyType;
+import org.apache.shindig.social.opensocial.model.Drinker;
+import org.apache.shindig.social.opensocial.model.ListField;
+import org.apache.shindig.social.opensocial.model.LookingFor;
+import org.apache.shindig.social.opensocial.model.Name;
+import org.apache.shindig.social.opensocial.model.NetworkPresence;
+import org.apache.shindig.social.opensocial.model.Organization;
+import org.apache.shindig.social.opensocial.model.Person;
+import org.apache.shindig.social.opensocial.model.Space;
+import org.apache.shindig.social.opensocial.model.Smoker;
+import org.apache.shindig.social.opensocial.model.Url;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.Basic;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.JoinTable;
+import javax.persistence.ManyToMany;
+import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
+import javax.persistence.OneToMany;
+import javax.persistence.PostLoad;
+import javax.persistence.PrePersist;
+import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+import javax.persistence.Transient;
+import javax.persistence.Version;
+
+/**
+ * Default Implementation of the Person object in the org.apache.shindig.social.opensocial.jpa.
+ */
+@Entity
+@Table(name = "mdl_widgetspace") // Space is a widgetspace where widgets live, parent is a course
+@NamedQueries(value = {
+    @NamedQuery(name = SpaceDb.FINDBY_SPACEID,
+        query = "select s from SpaceDb s where s.id = :id "),
+    @NamedQuery(name = SpaceDb.FINDBY_LIKE_SPACEID,
+        query = "select s from SpaceDb s where s.id like :id") })
+public class SpaceDb implements Space, DbObject {
+
+  public static final String FINDBY_SPACEID = "q.space.findbyspaceid";
+
+  public static final String PARAM_SPACEID = "id";
+
+  public static final String FINDBY_LIKE_SPACEID = "q.space.findbylikespaceid";
+
+  private static final String INTERESTS_PROPERTY = "interest";
+
+  private static final Map<String, FilterSpecification> FILTER_COLUMNS =
+    new HashMap<String, FilterSpecification>();
+
+  private static final FilterOperation[] ALL_FILTEROPTIONS = new FilterOperation[] {
+      FilterOperation.equals, FilterOperation.contains, FilterOperation.present,
+      FilterOperation.startsWith };
+  private static final FilterOperation[] NUMERIC_FILTEROPTIONS = new FilterOperation[] {
+      FilterOperation.equals, FilterOperation.present };
+  @SuppressWarnings("unused")
+  private static final FilterOperation[] EQUALS_FILTEROPTIONS =
+    new FilterOperation[] { FilterOperation.equals };
+
+  static {
+    FILTER_COLUMNS.put("displayName", new FilterSpecification("displayName", ALL_FILTEROPTIONS));
+
+    // the following are special operations which are accepted, but work differently
+    FILTER_COLUMNS.put("topFriends", new FilterSpecification());
+    FILTER_COLUMNS.put("hasApp", new FilterSpecification());
+  }
+
+  private static final FilterCapability FILTER_CAPABILITY = new FilterCapability() {
+    /**
+     * {@inheritDoc}
+     */
+    public String findFilterableProperty(String fieldName, FilterOperation filterOperation) {
+      FilterSpecification spec = FILTER_COLUMNS.get(fieldName);
+      if (spec != null) {
+        return spec.translateProperty(filterOperation);
+      }
+      return null;
+    }
+
+  };
+
+  public static final String JPQL_FINDALLPERSON = null;
+
+  // TODO The commented out query supports sorting by friend.score but needs a join with FriendDb which returns duplicates.
+  // Using 'group by' to avoid duplicates doesn't work in HSQLDB or Derby - causes a "Not in aggregate function or group by clause" jdbc exception.
+  // public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p join FriendDb f on p.objectId = f.friend.objectId where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+  public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+
+  public static final Object JPQL_FINDPERSON_BY_GROUP = null;
+
+  public static final Object JPQL_FINDSPACE = "select s from SpaceDb s where ";
+  public static final Object JPQL_FINDSPACES = "select s from SpaceDb s where ";
+
+  /**
+   * The internal object ID used for references to this object. Should be generated by the
+   * underlying storage mechanism
+   */
+  @Id
+  @GeneratedValue(strategy = IDENTITY)
+  @Column(name = "id")
+  private long objectId;
+  
+  /**
+   * The internal parentId and parentType used for references to the parent of a space.
+   */
+  @Basic
+  @Column(name = "course", length = 255)
+  private String parentId;
+  
+  @Transient // parentType is a course
+  protected String parentType;
+
+  /**
+   * An optimistic locking field.
+   */
+
+  @Transient
+  protected List<Address> addresses;
+  
+  @Transient
+  protected String location;
+
+  @Basic
+  @Column(name = "name", length = 255)
+  private String displayName;
+
+  @Basic
+  @Column(name = "name", length = 255, insertable = false, updatable = false)
+  private String name;
+  
+  @Transient
+  protected String picture;
+  
+  
+  /**
+   *
+   */
+  @Transient
+  protected List<ListField> emails;
+
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "intro", length = 255)
+  protected String description;
+
+  /**
+   *
+   */
+  @Transient
+  protected Boolean hasApp;
+
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "id", length = 255, insertable = false, updatable = false)
+  protected String id;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<ListField> ims;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<String> interests;
+
+  /**
+   *
+   */
+  // @Basic
+  // @Column(name = "timemodified")
+  // @Temporal(TemporalType.TIMESTAMP)
+  @Transient
+  protected Date updated;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<ListField> phoneNumbers;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<ListField> images;
+  
+  /**
+   *
+   */
+  @Transient
+  protected String status;
+
+  /**
+   *
+   */
+  @Transient
+  protected Long utcOffset;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<Url> urls;
+
+  // Note: Not in the opensocial js person object directly
+  @Transient
+  private boolean isOwner = false;
+
+  public SpaceDb() {
+  }
+
+  public SpaceDb(String id, String displayName) {
+    this.id = id;
+    this.displayName = displayName;
+  }
+
+  public List<Address> getAddresses() {
+    return addresses;
+  }
+
+  public void setAddresses(List<Address> addresses) {
+    this.addresses = addresses;
+  }
+
+  public List<ListField> getEmails() {
+    return emails;
+  }
+
+  public void setEmails(List<ListField> emails) {
+    this.emails = emails;
+  }
+
+  public Boolean getHasApp() {
+    return hasApp;
+  }
+
+  public void setHasApp(Boolean hasApp) {
+    this.hasApp = hasApp;
+  }
+
+  public String getParentId() {
+    return this.parentId;
+  }
+
+  public void setParentId(String parentId) {
+    this.parentId = parentId;
+  }
+  
+  public String getParentType() {
+    return "@space";
+  }
+
+  public void setParentType(String parentType) {
+    this.parentType = parentType;
+  }
+
+  public String getLocation() {
+    return this.location;
+  }
+
+  public void setLocation(String location) {
+    this.location = location;
+  }
+  
+  public String getName() {
+    return this.name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  
+  public String getId() {
+    return id;
+  }
+
+  public void setId(String id) {
+    this.id = id;
+  }
+
+  public List<ListField> getIms() {
+    return ims;
+  }
+
+  public void setIms(List<ListField> ims) {
+    this.ims = ims;
+  }
+
+  public List<String> getInterests() {
+    return interests;
+  }
+
+  public void setInterests(List<String> interests) {
+    this.interests = interests;
+  }
+
+  public Date getUpdated() {
+    if (updated == null) {
+      return null;
+    }
+    return new Date(updated.getTime());
+  }
+
+  public void setUpdated(Date updated) {
+    if (updated == null) {
+      this.updated = null;
+    } else {
+      this.updated = new Date(updated.getTime());
+    }
+  }
+
+  public List<ListField> getPhoneNumbers() {
+    return phoneNumbers;
+  }
+
+  public void setPhoneNumbers(List<ListField> phoneNumbers) {
+    this.phoneNumbers = phoneNumbers;
+  }
+
+  public List<ListField> getImages() {
+    return images;
+  }
+
+  public void setImages(List<ListField> images) {
+    this.images = images;
+  }
+
+  public String getDescription() {
+    return description;
+  }
+
+  public void setDescription(String description) {
+    this.description = description;
+  }
+  
+  public String getStatus() {
+    return status;
+  }
+
+  public void setStatus(String status) {
+    this.status = status;
+  }
+
+  public Long getUtcOffset() {
+    return utcOffset;
+  }
+
+  public void setUtcOffset(Long utcOffset) {
+    this.utcOffset = utcOffset;
+  }
+
+  public List<Url> getUrls() {
+    return urls;
+  }
+
+  public void setUrls(List<Url> urls) {
+    this.urls = urls;
+  }
+
+  public boolean getIsOwner() {
+    return isOwner;
+  }
+
+  public void setIsOwner(boolean isOwner) {
+    this.isOwner = isOwner;
+  }
+
+  // Proxied fields
+
+  public String getProfileUrl() {
+    return "widgetspace_url"+String.valueOf(objectId);  
+  }
+
+  public void setProfileUrl(String profileUrl) {
+    Url url = getListFieldWithType(PROFILE_URL_TYPE, getUrls());
+    if (url != null) {
+      url.setValue(profileUrl);
+    } else {
+      setUrls(addListField(new UrlDb(profileUrl, null, PROFILE_URL_TYPE), getUrls()));
+    }
+  }
+
+  public String getThumbnailUrl() {
+    String pic = picture;
+    if (pic == null || pic.equals("")) {
+      return "widgetspace_url/space_thumb.png";
+    }
+    
+    return "widgetspace_url/"+String.valueOf(objectId)+"/thumb/"+pic;        
+  }
+
+  public void setThumbnailUrl(String thumbnailUrl) {
+    ListField photo = getListFieldWithType(THUMBNAIL_PHOTO_TYPE, getImages());
+    if (photo != null) {
+      photo.setValue(thumbnailUrl);
+    } else {
+      setImages(addListField(new ListFieldDb(THUMBNAIL_PHOTO_TYPE, thumbnailUrl), getImages()));
+    }
+  }
+
+  private <T extends ListField> T getListFieldWithType(String type, List<T> list) {
+    if (list != null) {
+      for (T url : list) {
+        if (type.equalsIgnoreCase(url.getType())) {
+          return url;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private <T extends ListField> List<T> addListField(T field, List<T> list) {
+    if (list == null) {
+      list = Lists.newArrayList();
+    }
+    list.add(field);
+    return list;
+  }
+
+  /**
+   * @return the objectId
+   */
+  public long getObjectId() {
+    return Long.parseLong(id);
+  }
+
+  @PrePersist
+  public void populateDbFields() {
+
+    Map<String, List<String>> toSave = new HashMap<String, List<String>>();
+    toSave.put(INTERESTS_PROPERTY, this.interests);
+
+  }
+
+  @PostLoad
+  public void loadTransientFields() {
+
+
+    List<String> lookingFor = Lists.newArrayList();
+    this.interests = Lists.newArrayList();
+
+    Map<String, List<String>> toSave = Maps.newHashMap();
+
+    toSave.put(INTERESTS_PROPERTY, this.interests);
+
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.apache.shindig.social.opensocial.model.Person#getDisplayName()
+   */
+  public String getDisplayName() {
+    return displayName;
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.apache.shindig.social.opensocial.model.Person#setDisplayName(java.lang.String)
+   */
+  public void setDisplayName(String displayName) {
+    this.displayName = displayName;
+  }
+
+  public static FilterCapability getFilterCapability() {
+    return FILTER_CAPABILITY;
+
+  }
+
+  /** {@inheritDoc} */
+  public Map<String, ? extends Object> getAppData()
+  {
+    return null;
+  }
+
+  /** {@inheritDoc} */
+  public void setAppData( Map<String, ? extends Object> appData )
+  {
+  }
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/ActivityDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/ActivityDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/ActivityDb.java	(working copy)
@@ -65,7 +65,7 @@
 
   public static final String FINDBY_ACTIVITY_ID = "q.activity.findbyactivityid";
 
-  public static final String PARAM_USERID = "userId";
+  public static final String PARAM_PERSONID = "userId";
   
   public static final String PARAM_ACTIVITYID = "activityId";
    
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/AppDataServiceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/AppDataServiceDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/AppDataServiceDb.java	(working copy)
@@ -20,23 +20,29 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.inject.Inject;
+import com.google.common.collect.MapMaker;
 
+
 import org.apache.shindig.auth.SecurityToken;
 import org.apache.shindig.common.util.ImmediateFuture;
 import org.apache.shindig.protocol.DataCollection;
 import org.apache.shindig.protocol.ProtocolException;
-import org.apache.shindig.social.opensocial.jpa.ApplicationDataMapDb;
+import org.apache.shindig.social.opensocial.jpa.AppdataDb;
+import org.apache.shindig.social.opensocial.jpa.spi.JPQLUtils;
+import org.apache.shindig.social.opensocial.jpa.spi.SPIUtils;
 import org.apache.shindig.social.opensocial.spi.AppDataService;
 import org.apache.shindig.social.opensocial.spi.GroupId;
 import org.apache.shindig.social.opensocial.spi.UserId;
 
 import java.util.HashMap;
 import java.util.List;
+import java.util.ArrayList;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Future;
 
 import javax.persistence.EntityManager;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  *
@@ -56,18 +62,35 @@
   public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,
       Set<String> fields, SecurityToken token) throws ProtocolException {
 
-    List<ApplicationDataMapDb> dataMaps = getDataMap(userId, groupId, appId, token);
-    for (ApplicationDataMapDb adm : dataMaps) {
-      for (String f : fields) {
-        adm.getValues().remove(f);
+    if (appId == null) {
+      appId = token.getAppId();
+    }        
+    String uid = SPIUtils.getUserList(userId, token);
+    String contextType = "User";
+    long contextId = 0;
+    if (uid.startsWith("s_")) { // for space
+      // appdata for a space
+      contextId = Long.parseLong(uid.replaceFirst("s_",""));
+      contextType = "Space";
+    } else { // for person
+      contextId = Long.parseLong(uid);
+    }
+
+    Map<String,AppdataDb> dataMaps = getDataMap(contextId, contextType, groupId, appId);
+    
+    // TODO How should transactions be managed? Should samples be using warp-persist instead?
+    if (!entityManager.getTransaction().isActive()) {
+      entityManager.getTransaction().begin();
+    }
+    
+    // remove found fields
+    for (String f : fields) {
+      if (dataMaps.containsKey(f)) {
+        AppdataDb ad = dataMaps.get(f);
+        entityManager.remove(ad);
       }
     }
-     // TODO How should transactions be managed? Should samples be using warp-persist instead?
-     if (!entityManager.getTransaction().isActive()) {
-       entityManager.getTransaction().begin();
-     }
 
-    entityManager.flush();
     entityManager.getTransaction().commit();
 
     return ImmediateFuture.newInstance(null);
@@ -80,118 +103,165 @@
    * @param token
    * @return
    */
-  private List<ApplicationDataMapDb> getDataMap(UserId userId, GroupId groupId, String appId,
-      SecurityToken token) {
-    List<String> paramList = Lists.newArrayList();
-    paramList.add(SPIUtils.getUserList(userId, token));
+  private Map<String,AppdataDb> getDataMap(long contextId, String contextType, GroupId groupId, String appId) {
+    List<Long> paramList = Lists.newArrayList();
+    paramList.add(contextId);    
+    
     int lastParam = 1;
     StringBuilder sb = new StringBuilder();
 
     switch (groupId.getType()) {
     case all:
       // userId translates into all contacts
-      sb.append(ApplicationDataMapDb.FINDBY_ALL_GROUP);
-      sb.append(" and am.personId = ?").append(lastParam);
+      sb.append(AppdataDb.FINDBY_ALL_GROUP);
+      sb.append(" and ad.contextId = ?").append(lastParam);
       lastParam++;
       break;
     case deleted:
       // ignored
       break;
     case friends:
-      sb.append(ApplicationDataMapDb.FINDBY_FRIENDS_GROUP);
-      sb.append(" and am.personId = ?").append(lastParam);
+      sb.append(AppdataDb.FINDBY_FRIENDS_GROUP);
+      sb.append(" and ad.contextId = ?").append(lastParam);
       lastParam++;
       // userId translates into all friends
       break;
     case groupId:
-      sb.append(ApplicationDataMapDb.FINDBY_GROUP_GROUP);
-      sb.append(" and am.personId = ?").append(lastParam);
+      sb.append(AppdataDb.FINDBY_GROUP_GROUP);
+      sb.append(" and ad.contextId = ?").append(lastParam);
       lastParam++;
       sb.append(" and g.id = ?").append(lastParam);
-      paramList.add(groupId.getGroupId());
+      paramList.add(Long.parseLong(groupId.getGroupId()));
       lastParam++;
       // userId translates into friends within a group
       break;
     default: // including self
       // userId is the user Id
-      sb.append(ApplicationDataMapDb.FINDBY_SELF_GROUP);
-      sb.append(" am.personId = ?").append(lastParam);
+      sb.append(AppdataDb.FINDBY_SELF_GROUP);
+      sb.append(" ad.contextId = ?").append(lastParam);
+      sb.append(" and ad.contextType = '").append(contextType).append("'");
       lastParam++;
       break;
 
     }
-    sb.append(" and am.application.id = ?").append(lastParam);
+    sb.append(" and ad.applicationId = ?").append(lastParam);
     lastParam++;
-    paramList.add(appId);
-    return JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, null);
+    paramList.add(Long.parseLong(appId));
+    List<AppdataDb> dataMaps = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, null);
+    
+    Map<String, AppdataDb> results = new HashMap<String, AppdataDb>();
+    
+    for (AppdataDb ad : dataMaps) {
+      // build the hash "key" => Appdata for the key
+      results.put(ad.getName(),ad);
+    }
 
+    return results;
+
   }
 
   /**
+   * Filters contexts list to ids like: "s_1","s_2" -> "1","2"
+   */
+  private List<Long> removeContextInfo(List<String> contextList) {
+    List<Long> idList = Lists.newArrayList();
+    for (String c : contextList) {
+      idList.add(Long.parseLong(c.replaceFirst("s_","")));
+    }
+    return idList;
+  }
+
+  /**
    * {@inheritDoc}
    */
   public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,
       Set<String> fields, SecurityToken token) throws ProtocolException {
-    List<String> paramList = SPIUtils.getUserList(userIds, token);
+    
+    if (appId == null) {
+      appId = token.getAppId();
+    }    
+    List<String> contextList = SPIUtils.getUserList(userIds, token);
+    // for now all context are defined by the first context in the list
+    String firstContext = contextList.get(0); 
+    String contextType = "User";
+    String prefix = "";
+    if (firstContext.startsWith("s_")) {
+      // appdata for a space
+      contextType = "Space";
+      prefix = "s_";
+    }
+    
+    List<Long> paramList = removeContextInfo(contextList);
     int lastParam = 1;
     StringBuilder sb = new StringBuilder();
 
     switch (groupId.getType()) {
     case all:
       // userId translates into all contacts
-      sb.append(ApplicationDataMapDb.FINDBY_ALL_GROUP);
-      lastParam = JPQLUtils.addInClause(sb, "am", "personId", lastParam, paramList.size());
+      sb.append(AppdataDb.FINDBY_ALL_GROUP);
+      lastParam = JPQLUtils.addInClause(sb, "ad", "contextId", lastParam, paramList.size());
       break;
     case deleted:
       // ignored
       break;
     case friends:
-      sb.append(ApplicationDataMapDb.FINDBY_FRIENDS_GROUP);
+      sb.append(AppdataDb.FINDBY_FRIENDS_GROUP);
       lastParam = JPQLUtils.addInClause(sb, "p", "id", lastParam, paramList.size());
       sb.append(')');
       // userId translates into all friends
       break;
     case groupId:
-      sb.append(ApplicationDataMapDb.FINDBY_GROUP_GROUP);
-      lastParam = JPQLUtils.addInClause(sb, "am", "personId", lastParam, paramList.size());
+      sb.append(AppdataDb.FINDBY_GROUP_GROUP);
+      lastParam = JPQLUtils.addInClause(sb, "ad", "contextId", lastParam, paramList.size());
       sb.append(" and g.id = ?").append(lastParam);
-      paramList.add(groupId.getGroupId());
+      paramList.add(Long.parseLong(groupId.getGroupId()));
       lastParam++;
       // userId translates into friends within a group
       break;
     default: // including self
       // userId is the user Id
-      sb.append(ApplicationDataMapDb.FINDBY_SELF_GROUP);
-      lastParam = JPQLUtils.addInClause(sb, "am", "personId", lastParam, paramList.size());
+      sb.append(AppdataDb.FINDBY_SELF_GROUP);
+      lastParam = JPQLUtils.addInClause(sb, "ad", "contextId", lastParam, paramList.size());
+      sb.append(" and ad.contextType = '").append(contextType).append("'");
       break;
 
     }
-    sb.append(" and am.application.id = ?").append(lastParam);
+    sb.append(" and ad.applicationId = ?").append(lastParam);
     lastParam++;
-    paramList.add(appId);
+    paramList.add(Long.parseLong(appId));
 
     // load the map up
-    List<ApplicationDataMapDb> dataMaps = JPQLUtils.getListQuery(entityManager, sb.toString(),
+    List<AppdataDb> dataMaps = JPQLUtils.getListQuery(entityManager, sb.toString(),
         paramList, null);
     Map<String, Map<String, String>> results = new HashMap<String, Map<String, String>>();
 
     // only add in the fields
-    if (fields == null || fields.isEmpty()) {
-      for (ApplicationDataMapDb adm : dataMaps) {
-        results.put(adm.getPersonId(), adm.getValues());
+    if (fields == null || fields.isEmpty()) {      
+      for (AppdataDb ad : dataMaps) {
+        String key = prefix + ad.getContextId();
+        Map<String, String> m = results.get(key);
+        if (m == null) { // create new map and add it to results map
+           m = Maps.newHashMap();
+           results.put(key,m);
+        }
+        // add key-value to existing map
+        m.put(ad.getName(),ad.getValue());
       }
     } else {
-      for (ApplicationDataMapDb adm : dataMaps) {
-        Map<String, String> m = Maps.newHashMap();
-        for (String f : fields) {
-          String value = adm.getValues().get(f);
-          if (null != value) {
-            m.put(f, value);
+      for (AppdataDb ad : dataMaps) {
+        if (fields.contains(ad.getName())) { // do manipulations only if key is in fields
+          String key = prefix + ad.getContextId();
+          Map<String, String> m = results.get(key);
+          if (m == null) { // create new map and add it to results map
+             m = Maps.newHashMap();
+             results.put(key,m);
           }
+          // add key-value to existing map
+          m.put(ad.getName(),ad.getValue());
         }
-        results.put(adm.getPersonId(), m);
       }
     }
+    
     DataCollection dc = new DataCollection(results);
     return ImmediateFuture.newInstance(dc);
   }
@@ -200,20 +270,54 @@
    * {@inheritDoc}
    */
   public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,
-      Set<String> fields, Map<String, String> values, SecurityToken token)
-      throws ProtocolException {
-    List<ApplicationDataMapDb> dataMaps = getDataMap(userId, groupId, appId, token);
-    for (ApplicationDataMapDb adm : dataMaps) {
-      for (String f : fields) {
-        adm.getValues().put(f, values.get(f));
-      }
+      Set<String> fields, Map<String, String> values, SecurityToken token) throws ProtocolException {
+        
+    if (appId == null) {
+      appId = token.getAppId();
     }
-
+    String uid = SPIUtils.getUserList(userId, token);
+    String contextType = "User";
+    long contextId = 0;
+    if (uid.startsWith("s_")) { // for space
+      contextId = Long.parseLong(uid.replaceFirst("s_",""));
+      contextType = "Space";
+    } else { // for person
+      contextId = Long.parseLong(uid);
+    }
+    
+    Map<String,AppdataDb> dataMaps = getDataMap(contextId, contextType, groupId, appId);
+    
     // TODO How should transactions be managed? Should samples be using warp-persist instead?
     if (!entityManager.getTransaction().isActive()) {
       entityManager.getTransaction().begin();
     }
-    entityManager.flush();
+    
+    // go through all new values and update key-value
+    for (String k : values.keySet()) {
+      if (dataMaps.containsKey(k)) {
+        // update the key
+        AppdataDb ad = dataMaps.get(k);
+        ad.setValue(values.get(k));
+        entityManager.persist(ad);
+      } else {
+        // create the new key-value
+        AppdataDb ad = new AppdataDb();
+        ad.setContextId(contextId);
+        ad.setContextType(contextType);
+        ad.setApplicationId(Long.parseLong(appId));
+        ad.setName(k);
+        ad.setValue(values.get(k));
+        entityManager.persist(ad);
+      }
+    }
+
+    
+
+    // for (AppdataDb adm : dataMaps) {
+    //   entityManager.persist(adm);
+    // }
+    // entityManager.flush();
+    
     entityManager.getTransaction().commit();
 
     return ImmediateFuture.newInstance(null);
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/SpaceServiceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/SpaceServiceDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/SpaceServiceDb.java	(revision 0)
@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa.spi;
+
+import com.google.common.collect.Lists;
+import com.google.inject.Inject;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.ImmediateFuture;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.jpa.PersonDb;
+import org.apache.shindig.social.opensocial.jpa.SpaceDb;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.social.opensocial.jpa.spi.JPQLUtils;
+import org.apache.shindig.social.opensocial.jpa.spi.SPIUtils;
+import org.apache.shindig.social.opensocial.model.Space;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.SpaceService;
+import org.apache.shindig.social.opensocial.spi.Context;
+import org.apache.shindig.social.opensocial.spi.SpaceId;
+import org.apache.shindig.social.opensocial.spi.UserId;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+import java.util.regex.*;
+
+
+import javax.persistence.EntityManager;
+import javax.persistence.Query;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Implements the PersonService from the SPI binding to the JPA model and providing queries to
+ * support the OpenSocial implementation.
+ */
+public class SpaceServiceDb implements SpaceService {
+
+  /**
+   * This is the JPA entity manager, shared by all threads accessing this service (need to check
+   * that its really thread safe).
+   */
+  private EntityManager entityManager;
+
+  /**
+   * Create the PersonServiceDb, injecting an entity manager that is configured with the social
+   * model.
+   *
+   * @param entityManager the entity manager containing the social model.
+   */
+  @Inject
+  public SpaceServiceDb(EntityManager entityManager) {
+    this.entityManager = entityManager;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Future<RestfulCollection<Space>> getSpaces(Set<SpaceId> spaceIds, 
+		  CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // for each user id get the filtered userid using the token and then, get the users identified
+    // by the group id, the final set is filtered
+    // using the collectionOptions and return the fields requested.
+
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Space> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
+
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = SPIUtils.getSpaceList(spaceIds);
+    
+    sb.append(SpaceDb.JPQL_FINDSPACE);
+    lastPos = JPQLUtils.addInClause(sb, "s", "id", lastPos, paramList.size());
+
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+    	//addOrderClause(sb, collectionOptions);
+    	plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+    	plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Space> restCollection = new RestfulCollection<Space>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+
+  }
+
+  public Future<RestfulCollection<Space>> getSpacesForContext(Context context, 
+      CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // list of spaces is retrieved for a context
+
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Space> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
+
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = Lists.newArrayList();
+    
+    sb.append(SpaceDb.JPQL_FINDSPACES);
+    if(context.getContextType().equals("@person")){
+      sb.append("s.parentId = "+context.getContextId()+" and s.parentType = 'User'");
+    }else if (context.getContextType().equals("@space")){
+      sb.append("s.parentId = "+context.getContextId()+" and s.parentType = 'Space'");
+    }
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+    	//addOrderClause(sb, collectionOptions);
+    	plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+    	plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Space> restCollection = new RestfulCollection<Space>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Future<Space> getSpace(SpaceId spaceId, Set<String> fields, SecurityToken token)
+      throws ProtocolException {
+ 
+    Query q = null;
+    // gets space for spaceId from the database
+    q = entityManager.createNamedQuery(SpaceDb.FINDBY_SPACEID);
+    q.setParameter(SpaceDb.PARAM_SPACEID, spaceId.getSpaceId());
+    q.setFirstResult(0);
+    q.setMaxResults(1);
+   
+
+    List<?> plist = q.getResultList();
+    Space space = null;
+    if (plist != null && !plist.isEmpty()) {
+      space = (Space) plist.get(0);
+    }
+    return ImmediateFuture.newInstance(space);
+  }
+
+
+
+  /**
+   * Add a filter clause specified by the collection options.
+   *
+   * @param sb the query builder buffer
+   * @param collectionOptions the options
+   * @param lastPos the last positional parameter that was used so far in the query
+   * @return
+   */
+  private int addFilterClause(StringBuilder sb, FilterCapability filterable,
+      CollectionOptions collectionOptions, int lastPos) {
+    // this makes the filter value saf
+    String filter = filterable.findFilterableProperty(collectionOptions.getFilter(),
+        collectionOptions.getFilterOperation());
+    String filterValue = collectionOptions.getFilterValue();
+    int filterPos = 0;
+    if (FilterSpecification.isValid(filter)) {
+      if (FilterSpecification.isSpecial(filter)) {
+        if (SpaceService.HAS_APP_FILTER.equals(filter)) {
+          // Retrieves all friends with any data for this application.
+          // TODO: how do we determine which application is being talked about,
+          // the assumption below is wrong
+          filterPos = lastPos + 1;
+          sb.append(" f.application_id  = ?").append(filterPos);
+        } else if (SpaceService.TOP_FRIENDS_FILTER.equals(filter)) {
+          // Retrieves only the user's top friends, this is defined here by the implementation
+          // and there is an assumption that the sort order has already been applied.
+          // to do this we need to modify the collections options
+          // there will only ever b x friends in the list and it will only ever start at 1
+
+          collectionOptions.setFirst(1);
+          collectionOptions.setMax(20);
+
+        } else if (SpaceService.ALL_FILTER.equals(filter)) {
+           // select all, ie no filtering
+        } else if (SpaceService.IS_WITH_FRIENDS_FILTER.equals(filter)) {
+          filterPos = lastPos + 1;
+          sb.append(" f.friend  = ?").append(filterPos);
+        }
+      } else {
+        sb.append("p.").append(filter);
+        switch (collectionOptions.getFilterOperation()) {
+        case contains:
+          filterPos = lastPos + 1;
+          sb.append(" like ").append(" ?").append(filterPos);
+          filterValue = '%' + filterValue + '%';
+          collectionOptions.setFilter(filterValue);
+          break;
+        case equals:
+          filterPos = lastPos + 1;
+          sb.append(" = ").append(" ?").append(filterPos);
+          break;
+        case present:
+          sb.append(" is not null ");
+          break;
+        case startsWith:
+          filterPos = lastPos + 1;
+          sb.append(" like ").append(" ?").append(filterPos);
+          filterValue = '%' + filterValue + '%';
+          collectionOptions.setFilter(filterValue);
+          break;
+        }
+      }
+    }
+    return filterPos;
+  }
+
+  /**
+   * Add an order clause to the query string.
+   *
+   * @param sb the buffer for the query string
+   * @param collectionOptions the options to use for the order.
+   */
+  private void addOrderClause(StringBuilder sb, CollectionOptions collectionOptions) {
+    String sortBy = collectionOptions.getSortBy();
+    if (sortBy != null && sortBy.length() > 0) {
+      if (SpaceService.TOP_FRIENDS_SORT.equals(sortBy)) {
+        // TODO sorting by friend.score doesn't work right now because of group by issue (see above TODO)
+        // this assumes that the query is a join with the friends store.
+        sb.append(" order by f.score ");
+      } else {
+        if ("name".equals(sortBy)) {
+          // TODO Is this correct?
+          // If sortBy is name then order by p.name.familyName, p.name.givenName.
+          sb.append(" order by p.name.familyName, p.name.givenName ");
+        } else {
+          sb.append(" order by p.").append(sortBy);
+        }
+        switch (collectionOptions.getSortOrder()) {
+        case ascending:
+          sb.append(" asc ");
+          break;
+        case descending:
+          sb.append(" desc ");
+          break;
+        }
+      }
+    }
+  }
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ActivityServiceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ActivityServiceDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ActivityServiceDb.java	(working copy)
@@ -238,7 +238,7 @@
       SecurityToken token) {
     Query q = entityManager.createNamedQuery(ActivityDb.FINDBY_ACTIVITY_ID);
     String uid = SPIUtils.getUserList(userId, token);
-    q.setParameter(ActivityDb.PARAM_USERID, uid);
+    q.setParameter(ActivityDb.PARAM_PERSONID, uid);
     q.setParameter(ActivityDb.PARAM_ACTIVITYID, activityId);
     q.setFirstResult(0);
     q.setMaxResults(1);
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/DocumentServiceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/DocumentServiceDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/DocumentServiceDb.java	(revision 0)
@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa.spi;
+
+import com.google.common.collect.Lists;
+import com.google.inject.Inject;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.ImmediateFuture;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.jpa.PersonDb;
+import org.apache.shindig.social.opensocial.jpa.DocumentDb;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.social.opensocial.jpa.spi.JPQLUtils;
+import org.apache.shindig.social.opensocial.jpa.spi.SPIUtils;
+import org.apache.shindig.social.opensocial.model.Document;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.DocumentService;
+import org.apache.shindig.social.opensocial.spi.Context;
+import org.apache.shindig.social.opensocial.spi.DocumentId;
+import org.apache.shindig.social.opensocial.spi.UserId;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+import java.util.regex.*;
+
+
+import javax.persistence.EntityManager;
+import javax.persistence.Query;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Implements the PersonService from the SPI binding to the JPA model and providing queries to
+ * support the OpenSocial implementation.
+ */
+public class DocumentServiceDb implements DocumentService {
+
+  /**
+   * This is the JPA entity manager, shared by all threads accessing this service (need to check
+   * that its really thread safe).
+   */
+  private EntityManager entityManager;
+
+  /**
+   * Create the PersonServiceDb, injecting an entity manager that is configured with the social
+   * model.
+   *
+   * @param entityManager the entity manager containing the social model.
+   */
+  @Inject
+  public DocumentServiceDb(EntityManager entityManager) {
+    this.entityManager = entityManager;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Future<RestfulCollection<Document>> getDocuments(Set<DocumentId> documentIds, 
+		  CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // for each user id get the filtered userid using the token and then, get the users identified
+    // by the group id, the final set is filtered
+    // using the collectionOptions and return the fields requested.
+
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Document> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
+
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = SPIUtils.getDocumentList(documentIds);
+    
+    sb.append(DocumentDb.JPQL_FINDDOCUMENT);
+    lastPos = JPQLUtils.addInClause(sb, "a", "id", lastPos, paramList.size());
+
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+    	//addOrderClause(sb, collectionOptions);
+    	plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+    	plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Document> restCollection = new RestfulCollection<Document>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+
+  }
+
+  public Future<RestfulCollection<Document>> getDocumentsForContext(Context context, 
+		  CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // list of documents is retrieved for a context
+
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Document> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
+
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = Lists.newArrayList();
+    
+    sb.append(DocumentDb.JPQL_FINDDOCUMENTS);
+    if(context.getContextType().equals("@person")){
+    	sb.append("a.parentId = "+context.getContextId()+" and a.parentType = 'User'");
+    }else if (context.getContextType().equals("@space")){
+    	sb.append("a.parentId = "+context.getContextId()+" and a.parentType = 'Space'");
+    }
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+    	//addOrderClause(sb, collectionOptions);
+    	plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+    	plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Document> restCollection = new RestfulCollection<Document>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Future<Document> getDocument(DocumentId documentId, Set<String> fields, SecurityToken token)
+      throws ProtocolException {
+ 
+	Query q = null;
+	// gets document for documentId from the database
+	q = entityManager.createNamedQuery(DocumentDb.FINDBY_DOCUMENTID);
+	q.setParameter(DocumentDb.PARAM_DOCUMENTID, documentId.getDocumentId());
+	q.setFirstResult(0);
+	q.setMaxResults(1);
+		
+
+    List<?> plist = q.getResultList();
+    Document document = null;
+    if (plist != null && !plist.isEmpty()) {
+      document = (Document) plist.get(0);
+    }
+    return ImmediateFuture.newInstance(document);
+  }
+
+
+
+  /**
+   * Add a filter clause specified by the collection options.
+   *
+   * @param sb the query builder buffer
+   * @param collectionOptions the options
+   * @param lastPos the last positional parameter that was used so far in the query
+   * @return
+   */
+  private int addFilterClause(StringBuilder sb, FilterCapability filterable,
+      CollectionOptions collectionOptions, int lastPos) {
+    // this makes the filter value saf
+    String filter = filterable.findFilterableProperty(collectionOptions.getFilter(),
+        collectionOptions.getFilterOperation());
+    String filterValue = collectionOptions.getFilterValue();
+    int filterPos = 0;
+    if (FilterSpecification.isValid(filter)) {
+      if (FilterSpecification.isSpecial(filter)) {
+        if (DocumentService.HAS_APP_FILTER.equals(filter)) {
+          // Retrieves all friends with any data for this document.
+          // TODO: how do we determine which document is being talked about,
+          // the assumption below is wrong
+          filterPos = lastPos + 1;
+          sb.append(" f.document_id  = ?").append(filterPos);
+        } else if (DocumentService.TOP_FRIENDS_FILTER.equals(filter)) {
+          // Retrieves only the user's top friends, this is defined here by the implementation
+          // and there is an assumption that the sort order has already been applied.
+          // to do this we need to modify the collections options
+          // there will only ever b x friends in the list and it will only ever start at 1
+
+          collectionOptions.setFirst(1);
+          collectionOptions.setMax(20);
+
+        } else if (DocumentService.ALL_FILTER.equals(filter)) {
+           // select all, ie no filtering
+        } else if (DocumentService.IS_WITH_FRIENDS_FILTER.equals(filter)) {
+          filterPos = lastPos + 1;
+          sb.append(" f.friend  = ?").append(filterPos);
+        }
+      } else {
+        sb.append("p.").append(filter);
+        switch (collectionOptions.getFilterOperation()) {
+        case contains:
+          filterPos = lastPos + 1;
+          sb.append(" like ").append(" ?").append(filterPos);
+          filterValue = '%' + filterValue + '%';
+          collectionOptions.setFilter(filterValue);
+          break;
+        case equals:
+          filterPos = lastPos + 1;
+          sb.append(" = ").append(" ?").append(filterPos);
+          break;
+        case present:
+          sb.append(" is not null ");
+          break;
+        case startsWith:
+          filterPos = lastPos + 1;
+          sb.append(" like ").append(" ?").append(filterPos);
+          filterValue = '%' + filterValue + '%';
+          collectionOptions.setFilter(filterValue);
+          break;
+        }
+      }
+    }
+    return filterPos;
+  }
+
+  /**
+   * Add an order clause to the query string.
+   *
+   * @param sb the buffer for the query string
+   * @param collectionOptions the options to use for the order.
+   */
+  private void addOrderClause(StringBuilder sb, CollectionOptions collectionOptions) {
+    String sortBy = collectionOptions.getSortBy();
+    if (sortBy != null && sortBy.length() > 0) {
+      if (DocumentService.TOP_FRIENDS_SORT.equals(sortBy)) {
+        // TODO sorting by friend.score doesn't work right now because of group by issue (see above TODO)
+        // this assumes that the query is a join with the friends store.
+        sb.append(" order by f.score ");
+      } else {
+        if ("name".equals(sortBy)) {
+          // TODO Is this correct?
+          // If sortBy is name then order by p.name.familyName, p.name.givenName.
+          sb.append(" order by p.name.familyName, p.name.givenName ");
+        } else {
+          sb.append(" order by p.").append(sortBy);
+        }
+        switch (collectionOptions.getSortOrder()) {
+        case ascending:
+          sb.append(" asc ");
+          break;
+        case descending:
+          sb.append(" desc ");
+          break;
+        }
+      }
+    }
+  }
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ApplicationServiceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ApplicationServiceDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ApplicationServiceDb.java	(revision 0)
@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa.spi;
+
+import com.google.common.collect.Lists;
+import com.google.inject.Inject;
+
+import org.apache.shindig.auth.SecurityToken;
+import org.apache.shindig.common.util.ImmediateFuture;
+import org.apache.shindig.protocol.ProtocolException;
+import org.apache.shindig.protocol.RestfulCollection;
+import org.apache.shindig.social.opensocial.jpa.PersonDb;
+import org.apache.shindig.social.opensocial.jpa.ApplicationDb;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.social.opensocial.jpa.spi.JPQLUtils;
+import org.apache.shindig.social.opensocial.jpa.spi.SPIUtils;
+import org.apache.shindig.social.opensocial.model.Application;
+import org.apache.shindig.social.opensocial.spi.CollectionOptions;
+import org.apache.shindig.social.opensocial.spi.GroupId;
+import org.apache.shindig.social.opensocial.spi.ApplicationService;
+import org.apache.shindig.social.opensocial.spi.Context;
+import org.apache.shindig.social.opensocial.spi.ApplicationId;
+import org.apache.shindig.social.opensocial.spi.UserId;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Future;
+import java.util.regex.*;
+
+
+import javax.persistence.EntityManager;
+import javax.persistence.Query;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * Implements the PersonService from the SPI binding to the JPA model and providing queries to
+ * support the OpenSocial implementation.
+ */
+public class ApplicationServiceDb implements ApplicationService {
+
+  /**
+   * This is the JPA entity manager, shared by all threads accessing this service (need to check
+   * that its really thread safe).
+   */
+  private EntityManager entityManager;
+
+  /**
+   * Create the PersonServiceDb, injecting an entity manager that is configured with the social
+   * model.
+   *
+   * @param entityManager the entity manager containing the social model.
+   */
+  @Inject
+  public ApplicationServiceDb(EntityManager entityManager) {
+    this.entityManager = entityManager;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Future<RestfulCollection<Application>> getApplications(Set<ApplicationId> applicationIds, 
+		  CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // for each user id get the filtered userid using the token and then, get the users identified
+    // by the group id, the final set is filtered
+    // using the collectionOptions and return the fields requested.
+
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Application> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
+
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = SPIUtils.getApplicationList(applicationIds);
+    
+    sb.append(ApplicationDb.JPQL_FINDWIDGET);
+    lastPos = JPQLUtils.addInClause(sb, "w", "id", lastPos, paramList.size());
+
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+    	//addOrderClause(sb, collectionOptions);
+    	plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+    	plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Application> restCollection = new RestfulCollection<Application>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+
+  }
+
+  public Future<RestfulCollection<Application>> getApplicationsForContext(Context context, 
+		  CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // list of applications is retrieved for a context
+
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Application> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
+
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = Lists.newArrayList();
+    
+    sb.append(ApplicationDb.JPQL_FINDWIDGETS);
+    if(context.getContextType().equals("@person")){
+    	sb.append("w.parentId = "+context.getContextId()+" and w.parentType = 'User'");
+    }else if (context.getContextType().equals("@space")){
+    	sb.append("w.parentId = "+context.getContextId()+" and w.parentType = 'Space'");
+    }
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+    	//addOrderClause(sb, collectionOptions);
+    	plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+    	plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Application> restCollection = new RestfulCollection<Application>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Future<Application> getApplication(ApplicationId applicationId, Set<String> fields, SecurityToken token)
+      throws ProtocolException {
+ 
+	Query q = null;
+	// gets application for applicationId from the database
+	q = entityManager.createNamedQuery(ApplicationDb.FINDBY_WIDGETID);
+	q.setParameter(ApplicationDb.PARAM_WIDGETID, applicationId.getApplicationId());
+	q.setFirstResult(0);
+	q.setMaxResults(1);
+		
+
+    List<?> plist = q.getResultList();
+    Application application = null;
+    if (plist != null && !plist.isEmpty()) {
+      application = (Application) plist.get(0);
+    }
+    return ImmediateFuture.newInstance(application);
+  }
+
+
+
+  /**
+   * Add a filter clause specified by the collection options.
+   *
+   * @param sb the query builder buffer
+   * @param collectionOptions the options
+   * @param lastPos the last positional parameter that was used so far in the query
+   * @return
+   */
+  private int addFilterClause(StringBuilder sb, FilterCapability filterable,
+      CollectionOptions collectionOptions, int lastPos) {
+    // this makes the filter value saf
+    String filter = filterable.findFilterableProperty(collectionOptions.getFilter(),
+        collectionOptions.getFilterOperation());
+    String filterValue = collectionOptions.getFilterValue();
+    int filterPos = 0;
+    if (FilterSpecification.isValid(filter)) {
+      if (FilterSpecification.isSpecial(filter)) {
+        if (ApplicationService.HAS_APP_FILTER.equals(filter)) {
+          // Retrieves all friends with any data for this application.
+          // TODO: how do we determine which application is being talked about,
+          // the assumption below is wrong
+          filterPos = lastPos + 1;
+          sb.append(" f.application_id  = ?").append(filterPos);
+        } else if (ApplicationService.TOP_FRIENDS_FILTER.equals(filter)) {
+          // Retrieves only the user's top friends, this is defined here by the implementation
+          // and there is an assumption that the sort order has already been applied.
+          // to do this we need to modify the collections options
+          // there will only ever b x friends in the list and it will only ever start at 1
+
+          collectionOptions.setFirst(1);
+          collectionOptions.setMax(20);
+
+        } else if (ApplicationService.ALL_FILTER.equals(filter)) {
+           // select all, ie no filtering
+        } else if (ApplicationService.IS_WITH_FRIENDS_FILTER.equals(filter)) {
+          filterPos = lastPos + 1;
+          sb.append(" f.friend  = ?").append(filterPos);
+        }
+      } else {
+        sb.append("p.").append(filter);
+        switch (collectionOptions.getFilterOperation()) {
+        case contains:
+          filterPos = lastPos + 1;
+          sb.append(" like ").append(" ?").append(filterPos);
+          filterValue = '%' + filterValue + '%';
+          collectionOptions.setFilter(filterValue);
+          break;
+        case equals:
+          filterPos = lastPos + 1;
+          sb.append(" = ").append(" ?").append(filterPos);
+          break;
+        case present:
+          sb.append(" is not null ");
+          break;
+        case startsWith:
+          filterPos = lastPos + 1;
+          sb.append(" like ").append(" ?").append(filterPos);
+          filterValue = '%' + filterValue + '%';
+          collectionOptions.setFilter(filterValue);
+          break;
+        }
+      }
+    }
+    return filterPos;
+  }
+
+  /**
+   * Add an order clause to the query string.
+   *
+   * @param sb the buffer for the query string
+   * @param collectionOptions the options to use for the order.
+   */
+  private void addOrderClause(StringBuilder sb, CollectionOptions collectionOptions) {
+    String sortBy = collectionOptions.getSortBy();
+    if (sortBy != null && sortBy.length() > 0) {
+      if (ApplicationService.TOP_FRIENDS_SORT.equals(sortBy)) {
+        // TODO sorting by friend.score doesn't work right now because of group by issue (see above TODO)
+        // this assumes that the query is a join with the friends store.
+        sb.append(" order by f.score ");
+      } else {
+        if ("name".equals(sortBy)) {
+          // TODO Is this correct?
+          // If sortBy is name then order by p.name.familyName, p.name.givenName.
+          sb.append(" order by p.name.familyName, p.name.givenName ");
+        } else {
+          sb.append(" order by p.").append(sortBy);
+        }
+        switch (collectionOptions.getSortOrder()) {
+        case ascending:
+          sb.append(" asc ");
+          break;
+        case descending:
+          sb.append(" desc ");
+          break;
+        }
+      }
+    }
+  }
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/JPASocialModule.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/JPASocialModule.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/JPASocialModule.java	(working copy)
@@ -25,9 +25,23 @@
 
 import org.apache.commons.io.IOUtils;
 import org.apache.shindig.social.opensocial.jpa.eclipselink.EclipseEntityManagerProvider;
+import org.apache.shindig.social.opensocial.jpa.spi.ActivityServiceDb;
+import org.apache.shindig.social.opensocial.jpa.spi.AppDataServiceDb;
+import org.apache.shindig.social.opensocial.jpa.spi.PersonServiceDb;    
+import org.apache.shindig.social.opensocial.jpa.spi.SpaceServiceDb;    
+import org.apache.shindig.social.opensocial.jpa.spi.ApplicationServiceDb;    
+import org.apache.shindig.social.opensocial.jpa.spi.DocumentServiceDb;  
 import org.apache.shindig.social.opensocial.spi.ActivityService;
 import org.apache.shindig.social.opensocial.spi.AppDataService;
 import org.apache.shindig.social.opensocial.spi.PersonService;
+import org.apache.shindig.social.opensocial.spi.AlbumService;
+import org.apache.shindig.social.opensocial.spi.MediaItemService;
+import org.apache.shindig.social.opensocial.spi.MessageService;
+import org.apache.shindig.social.opensocial.spi.PersonService;
+import org.apache.shindig.social.opensocial.spi.SpaceService;
+import org.apache.shindig.social.opensocial.spi.ApplicationService;
+import org.apache.shindig.social.opensocial.spi.DocumentService;
+import org.apache.shindig.social.sample.spi.JsonDbOpensocialService;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -91,6 +105,14 @@
     bind(ActivityService.class).to(ActivityServiceDb.class)
         .in(Scopes.SINGLETON);
     bind(PersonService.class).to(PersonServiceDb.class).in(Scopes.SINGLETON);
+    bind(SpaceService.class).to(SpaceServiceDb.class).in(Scopes.SINGLETON);  
     bind(AppDataService.class).to(AppDataServiceDb.class).in(Scopes.SINGLETON);
+    bind(ApplicationService.class).to(ApplicationServiceDb.class).in(Scopes.SINGLETON);
+    bind(DocumentService.class).to(DocumentServiceDb.class).in(Scopes.SINGLETON);
+    
+    //Temporal
+    bind(AlbumService.class).to(JsonDbOpensocialService.class);
+    bind(MediaItemService.class).to(JsonDbOpensocialService.class);
+    bind(MessageService.class).to(JsonDbOpensocialService.class);
   }
 }
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/SPIUtils.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/SPIUtils.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/SPIUtils.java	(working copy)
@@ -22,6 +22,9 @@
 
 import org.apache.shindig.auth.SecurityToken;
 import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.SpaceId;
+import org.apache.shindig.social.opensocial.spi.ApplicationId;
+import org.apache.shindig.social.opensocial.spi.DocumentId;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -55,8 +58,70 @@
     }
     return paramList;
   }
+  
+  /**
+   * @param spaceIds
+   * @param token
+   * @return
+   */
+  public static List<String> getSpaceList(Set<SpaceId> spaceIds) {
+    // TODO What's the use of userIdMap?
+    HashMap<String, String> spaceIdMap = Maps.newHashMap();
+    List<String> paramList = Lists.newArrayList();
+    for (SpaceId s : spaceIds) {
+      try {
+    	  String sid = s.getSpaceId(); 
+    	  spaceIdMap.put(sid, sid);
+    	  paramList.add(sid);
+      } catch (IllegalStateException istate) {
+        // ignore the space id.
+      }
+    }
+    return paramList;
+  }
+  
+  /**
+   * @param applicationIds
+   * @param token
+   * @return
+   */
+  public static List<String> getApplicationList(Set<ApplicationId> applicationIds) {
+    // TODO What's the use of userIdMap?
+    HashMap<String, String> applicationIdMap = Maps.newHashMap();
+    List<String> paramList = Lists.newArrayList();
+    for (ApplicationId a : applicationIds) {
+      try {
+    	  String aid = a.getApplicationId(); 
+    	  applicationIdMap.put(aid, aid);
+    	  paramList.add(aid);
+      } catch (IllegalStateException istate) {
+        // ignore the application id.
+      }
+    }
+    return paramList;
+  }
 
   /**
+   * @param documentIds
+   * @param token
+   * @return
+   */
+  public static List<String> getDocumentList(Set<DocumentId> documentIds) {
+    // TODO What's the use of userIdMap?
+    HashMap<String, String> documentIdMap = Maps.newHashMap();
+    List<String> paramList = Lists.newArrayList();
+    for (DocumentId d : documentIds) {
+      try {
+    	  String did = d.getDocumentId(); 
+    	  documentIdMap.put(did, did);
+    	  paramList.add(did);
+      } catch (IllegalStateException istate) {
+        // ignore the document id.
+      }
+    }
+    return paramList;
+  }   
+  /**
    * @param userId
    * @param token
    * @return
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/PersonServiceDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/PersonServiceDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/PersonServiceDb.java	(working copy)
@@ -25,18 +25,26 @@
 import org.apache.shindig.protocol.ProtocolException;
 import org.apache.shindig.protocol.RestfulCollection;
 import org.apache.shindig.social.opensocial.jpa.PersonDb;
+import org.apache.shindig.social.opensocial.jpa.SpaceDb;
+import org.apache.shindig.social.opensocial.jpa.PermissionDb;
 import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
 import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.social.opensocial.jpa.spi.JPQLUtils;
+import org.apache.shindig.social.opensocial.jpa.spi.SPIUtils;
 import org.apache.shindig.social.opensocial.model.Person;
+import org.apache.shindig.social.opensocial.model.Space;
 import org.apache.shindig.social.opensocial.spi.CollectionOptions;
 import org.apache.shindig.social.opensocial.spi.GroupId;
 import org.apache.shindig.social.opensocial.spi.PersonService;
 import org.apache.shindig.social.opensocial.spi.UserId;
+import org.apache.shindig.social.opensocial.spi.Context;
 
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Future;
+import java.util.regex.*;
 
+
 import javax.persistence.EntityManager;
 import javax.persistence.Query;
 import javax.servlet.http.HttpServletResponse;
@@ -51,7 +59,7 @@
    * This is the JPA entity manager, shared by all threads accessing this service (need to check
    * that its really thread safe).
    */
-  private EntityManager entiyManager;
+  private EntityManager entityManager;
 
   /**
    * Create the PersonServiceDb, injecting an entity manager that is configured with the social
@@ -61,7 +69,7 @@
    */
   @Inject
   public PersonServiceDb(EntityManager entityManager) {
-    this.entiyManager = entityManager;
+    this.entityManager = entityManager;
   }
 
   /**
@@ -99,6 +107,21 @@
       // sb.append(" group by p ");
       break;
     case groupId:
+      // implementation is required to support the requests implemented for graaasp
+//        switch ($group_id) {
+//       case '@spaces':
+//         $ret = $this->getPersonSpacesIds($user_id);
+//         break;
+//       case '@people':
+//         $ret = $this->getSpacePeopleIds($user_id);
+//         break;
+//       case '@administrators':
+//         $ret = $this->getAdministratorsIds($user_id);
+//         break;
+//       case '@members':
+//         $ret = $this->getMembersIds($user_id);
+//         break;
+         
       // select those in the group
       sb.append(PersonDb.JPQL_FINDPERSON_BY_GROUP);
       lastPos = JPQLUtils.addInClause(sb, "p", "id", lastPos, paramList.size());
@@ -119,7 +142,7 @@
     }
 
     if (GroupId.Type.self.equals(groupId.getType())) {
-      plist = JPQLUtils.getListQuery(entiyManager, sb.toString(), paramList, collectionOptions);
+      plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
       totalResults = Long.valueOf(1);
       if (plist.isEmpty()) {
         throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, "Person not found");
@@ -132,12 +155,12 @@
       }
 
       // Get total results, that is count the total number of rows for this query
-      totalResults = JPQLUtils.getTotalResults(entiyManager, sb.toString(), paramList);
+      totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
 
       // Execute ordered and paginated query
       if (totalResults > 0) {
         addOrderClause(sb, collectionOptions);
-        plist = JPQLUtils.getListQuery(entiyManager, sb.toString(), paramList, collectionOptions);
+        plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
       }
 
       if (plist == null) {
@@ -159,10 +182,63 @@
   public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)
       throws ProtocolException {
     String uid = id.getUserId(token);
-    Query q = entiyManager.createNamedQuery(PersonDb.FINDBY_PERSONID);
+    Query q = null;
+    
+    if (uid.startsWith("s_")) { // for spaces
+      // Current implementation to support owner for spaces
+      // Takes space as context and viewer from security token
+      String spaceId = uid.replaceFirst("s_","");
+      String viewerId = token.getViewerId();
+      
+      // Get Id of moodle course for this widgetspace
+      String moodleCourseId = "";
+      // gets space for spaceId from the database
+      q = entityManager.createNamedQuery(SpaceDb.FINDBY_SPACEID);
+      q.setParameter(SpaceDb.PARAM_SPACEID, spaceId);
+      q.setFirstResult(0);
+      q.setMaxResults(1);
+      List<?> plist = q.getResultList();
+      if (plist != null && !plist.isEmpty()) {
+        Space s = (Space) plist.get(0);
+        moodleCourseId = s.getParentId();
+      }
+      
+      // get course owners
+      StringBuilder sb = new StringBuilder();
+      sb.append(PermissionDb.JPQL_OWNERS_BY_MOODLE_COURSE);
+      sb.append(moodleCourseId).append("')");
+      List<String> owners = JPQLUtils.getListQuery(entityManager, sb.toString(),
+          Lists.newArrayList(), null);
+          
+      /**
+       * Only course teachers and managers are considered to be owners
+       * Site administrators are not the owners of widgetspaces
+       * If we want to add them as owners we should append mdl_config -> siteadmins
+       * to PersonServiceDb.java (getPerson) -> owners variable
+       */
+                  
+      // If viewer is in the list of owners for a space it returns him, 
+      // otherwise returns first user from owners list.
+      if (owners.size() == 0) {
+        throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND ,"space does not have owners!");
+      }
+      
+      uid = owners.get(0);
+      for (String owner : owners) {
+        if (owner.equals(viewerId)) {
+          uid = viewerId; // viewer is the owner, set it
+          break;
+        }
+      }     
+      
+    }
+    
+    // uid is set up now: either user-owner or owner of a space
+    q = entityManager.createNamedQuery(PersonDb.FINDBY_PERSONID);
     q.setParameter(PersonDb.PARAM_PERSONID, uid);
     q.setFirstResult(0);
     q.setMaxResults(1);
+    
     List<?> plist = q.getResultList();
     Person person = null;
     if (plist != null && !plist.isEmpty()) {
@@ -171,8 +247,56 @@
     return ImmediateFuture.newInstance(person);
   }
 
+  public Future<RestfulCollection<Person>> getPeopleForContext(Context context, 
+      CollectionOptions collectionOptions, Set<String> fields,
+       SecurityToken token) throws ProtocolException {
+    // list of spaces is retrieved for a context
 
+    // not dealing with the collection options at the moment, and not the fields because they are
+    // either lazy or at no extra costs, the consumer will either access the properties or not
+    List<Person> plist = null;
+    int lastPos = 1;
+    Long totalResults = null;
 
+    StringBuilder sb = new StringBuilder();
+    // sanitize the list to get the uid's and remove duplicates
+    List<String> paramList = Lists.newArrayList();
+    
+    // finds people connected (in Graaasp sense) to other people
+    // or spaces
+    sb.append(PersonDb.JPQL_FINDPERSON_BY_PERMISSIONS);
+    // add permission to request
+    if(context.getContextType().equals("@person")){
+     sb.append("p.itemId = "+context.getContextId()+" and p.itemType = 'User')");
+    }else if (context.getContextType().equals("@space")){
+     sb.append("p.itemId = "+context.getContextId()+" and p.itemType = 'Space')");
+    }
+    // sb.append(PersonDb.JPQL_PERMISSIONS);
+    // sb.append("p.itemId = "+context.getContextId()+" and p.itemType = 'Space'");
+    
+    // Get total results, that is count the total number of rows for this query
+    // totalResults = JPQLUtils.getTotalResults(entityManager, sb.toString(), paramList);
+    
+    // Execute ordered and paginated query
+    //if (totalResults > 0) {
+      //addOrderClause(sb, collectionOptions);
+      plist = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, collectionOptions);
+    //}
+
+    if (plist == null) {
+      plist = Lists.newArrayList();
+    }
+    // FIXME: use JPQLUtils.getTotalResults for it
+    totalResults = new Long(plist.size());
+    // all of the above could equally have been placed into a thread to overlay the
+    // db wait times.
+    RestfulCollection<Person> restCollection = new RestfulCollection<Person>(
+        plist, collectionOptions.getFirst(), totalResults.intValue(), collectionOptions.getMax());
+    return ImmediateFuture.newInstance(restCollection);
+  }
+  
+  
+
   /**
    * Add a filter clause specified by the collection options.
    *
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/AppdataDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/AppdataDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/AppdataDb.java	(revision 0)
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa;
+
+import static javax.persistence.CascadeType.ALL;
+import static javax.persistence.GenerationType.IDENTITY;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.MapMaker;
+
+import org.apache.shindig.social.opensocial.jpa.api.DbObject;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.Basic;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.MapKey;
+import javax.persistence.OneToMany;
+import javax.persistence.PostLoad;
+import javax.persistence.PrePersist;
+import javax.persistence.Table;
+import javax.persistence.Transient;
+import javax.persistence.Version;
+
+
+/**
+ * An application data map is the map of data for a single key within an application.
+ */
+@Entity
+@Table(name="mdl_widgetspace_appdatas")
+public class AppdataDb implements DbObject {
+  /**
+   * The object needs to be seializable (map).
+   */
+  private static final long serialVersionUID = 8017568825925047318L;
+
+  public static final String FINDBY_ALL_GROUP = null;
+
+  public static final String FINDBY_FRIENDS_GROUP = "select ad from AppdataDb ad where ad.personId in (select f.friend.id from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+
+  public static final String FINDBY_GROUP_GROUP = null;
+
+  public static final String FINDBY_SELF_GROUP = "select ad from AppdataDb ad where ";
+
+  /**
+   * The internal object ID used for references to this object. Should be generated by the
+   * underlying storage mechanism
+   */
+  @Id
+  @GeneratedValue(strategy = IDENTITY)
+  @Column(name = "id")
+  protected long id;
+
+  @Basic
+  @Column(name = "application_id")
+  protected long applicationId;
+
+  /**
+   * A Application Data Map belongs to a set of maps associated with an application.
+   * The link from Application to DataMap is not navigable since it may contain 1000's of entries.
+   */
+  // @ManyToOne(targetEntity=ApplicationDb.class)
+  // @JoinColumn(name="application_id", referencedColumnName="oid")
+  @Transient
+  protected ApplicationDb application;
+
+  @Basic
+  @Column(name="context_id")
+  protected long contextId;
+
+  @Basic
+  @Column(name="context_type")
+  protected String contextType;
+  
+  @Basic
+  @Column(name="name", length=255)
+  protected String name;
+  
+  
+  @Basic
+  @Column(name="value", length=4096)
+  protected String value;
+  
+
+  /**
+   * @return the id
+   */
+  public long getId() {
+    return id;
+  }
+  
+  /**
+   * @return the id
+   */
+  public long getObjectId() {
+    return id;
+  }
+  
+  /**
+   * @return the applicationId
+   */
+  public long getApplicationId() {
+    return applicationId;
+  }
+
+  /**
+   * @param applicationId to set
+   */
+  public void setApplicationId(long applicationId) {
+    this.applicationId = applicationId;
+  }
+
+  /**
+   * @return the contextId
+   */
+  public long getContextId() {
+    return contextId;
+  }
+
+  /**
+   * @param contextId the contextId to set
+   */
+  public void setContextId(long contextId) {
+    this.contextId = contextId;
+  }
+  
+  /**
+   * @return the contextType
+   */
+  public String getContextType() {
+    return contextType;
+  }
+
+  /**
+   * @param contextType the contextType to set
+   */
+  public void setContextType(String contextType) {
+    this.contextType = contextType;
+  }
+  
+  /**
+   * @return the name
+   */
+  public String getName() {
+    return name;
+  }
+
+  /**
+   * @param name the name to set
+   */
+  public void setName(String name) {
+    this.name = name;
+  }
+  
+  /**
+   * @return the value
+   */
+  public String getValue() {
+    return value;
+  }
+
+  /**
+   * @param value the value to set
+   */
+  public void setValue(String value) {
+    this.value = value;
+  }
+  
+
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/DocumentDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/DocumentDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/DocumentDb.java	(revision 0)
@@ -0,0 +1,503 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa;
+
+import static javax.persistence.CascadeType.ALL;
+import static javax.persistence.CascadeType.MERGE;
+import static javax.persistence.CascadeType.PERSIST;
+import static javax.persistence.CascadeType.REFRESH;
+import static javax.persistence.GenerationType.IDENTITY;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
+import org.apache.shindig.social.opensocial.jpa.api.DbObject;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.FilterOperation;
+import org.apache.shindig.social.opensocial.model.Account;
+import org.apache.shindig.social.opensocial.model.Address;
+import org.apache.shindig.social.opensocial.model.BodyType;
+import org.apache.shindig.social.opensocial.model.Drinker;
+import org.apache.shindig.social.opensocial.model.ListField;
+import org.apache.shindig.social.opensocial.model.LookingFor;
+import org.apache.shindig.social.opensocial.model.Name;
+import org.apache.shindig.social.opensocial.model.NetworkPresence;
+import org.apache.shindig.social.opensocial.model.Organization;
+import org.apache.shindig.social.opensocial.model.Person;
+import org.apache.shindig.social.opensocial.model.Document;
+import org.apache.shindig.social.opensocial.model.Smoker;
+import org.apache.shindig.social.opensocial.model.Url;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.Basic;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.JoinTable;
+import javax.persistence.ManyToMany;
+import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
+import javax.persistence.OneToMany;
+import javax.persistence.PostLoad;
+import javax.persistence.PrePersist;
+import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+import javax.persistence.Transient;
+import javax.persistence.Version;
+
+/**
+ * Default Implementation of the Person object in the org.apache.shindig.social.opensocial.jpa.
+ */
+@Entity
+@Table(name = "documents") // this table does not exist in moodle
+@NamedQueries(value = {
+    @NamedQuery(name = DocumentDb.FINDBY_DOCUMENTID,
+        query = "select a from DocumentDb a where a.id = :id "),
+    @NamedQuery(name = DocumentDb.FINDBY_LIKE_DOCUMENTID,
+        query = "select a from DocumentDb a where a.id like :id") })
+public class DocumentDb implements Document, DbObject {
+
+  public static final String FINDBY_DOCUMENTID = "q.asset.findbyassetid";
+
+  public static final String PARAM_DOCUMENTID = "id";
+
+  public static final String FINDBY_LIKE_DOCUMENTID = "q.asset.findbylikeassetid";
+
+  private static final String INTERESTS_PROPERTY = "interest";
+
+  private static final Map<String, FilterSpecification> FILTER_COLUMNS =
+    new HashMap<String, FilterSpecification>();
+
+  private static final FilterOperation[] ALL_FILTEROPTIONS = new FilterOperation[] {
+      FilterOperation.equals, FilterOperation.contains, FilterOperation.present,
+      FilterOperation.startsWith };
+  private static final FilterOperation[] NUMERIC_FILTEROPTIONS = new FilterOperation[] {
+      FilterOperation.equals, FilterOperation.present };
+  @SuppressWarnings("unused")
+  private static final FilterOperation[] EQUALS_FILTEROPTIONS =
+    new FilterOperation[] { FilterOperation.equals };
+
+  static {
+    FILTER_COLUMNS.put("displayName", new FilterSpecification("displayName", ALL_FILTEROPTIONS));
+
+    // the following are special operations which are accepted, but work differently
+    FILTER_COLUMNS.put("topFriends", new FilterSpecification());
+    FILTER_COLUMNS.put("hasApp", new FilterSpecification());
+  }
+
+  private static final FilterCapability FILTER_CAPABILITY = new FilterCapability() {
+    /**
+     * {@inheritDoc}
+     */
+    public String findFilterableProperty(String fieldName, FilterOperation filterOperation) {
+      FilterSpecification spec = FILTER_COLUMNS.get(fieldName);
+      if (spec != null) {
+        return spec.translateProperty(filterOperation);
+      }
+      return null;
+    }
+
+  };
+
+  public static final String JPQL_FINDALLPERSON = null;
+
+  // TODO The commented out query supports sorting by friend.score but needs a join with FriendDb which returns duplicates.
+  // Using 'group by' to avoid duplicates doesn't work in HSQLDB or Derby - causes a "Not in aggregate function or group by clause" jdbc exception.
+  // public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p join FriendDb f on p.objectId = f.friend.objectId where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+  public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+
+  public static final Object JPQL_FINDPERSON_BY_GROUP = null;
+
+  public static final Object JPQL_FINDDOCUMENT = "select a from DocumentDb a where ";
+  public static final Object JPQL_FINDDOCUMENTS = "select a from DocumentDb a where ";
+
+  /**
+   * The internal object ID used for references to this object. Should be generated by the
+   * underlying storage mechanism
+   */
+  @Id
+  @GeneratedValue(strategy = IDENTITY)
+  @Column(name = "id")
+  private long objectId;
+  
+  /**
+   * The internal parentId and parentType used for references to the parent of a asset.
+   */
+  @Basic
+  @Column(name = "parent_id", length = 255)
+  private String parentId;
+  
+  @Basic
+  @Column(name = "parent_type", length = 255)
+  protected String parentType;
+
+  /**
+   * An optimistic locking field.
+   */
+
+  @Basic
+  @Column(name = "entity", length = 255)
+  protected String documentEntity;
+  
+  @Basic
+  @Column(name = "format_settings_type", length = 255)
+  protected String documentType;
+
+  @Transient
+  protected String author;
+  
+  @Transient
+  protected String authorEmail;
+
+  @Basic
+  @Column(name = "name", length = 255)
+  private String displayName;
+
+  @Basic
+  @Column(name = "name", length = 255, insertable = false, updatable = false)
+  private String name;
+  
+  @Basic
+  @Column(name = "picture")
+  protected String picture;
+  
+  
+  /**
+   *
+   */
+  @Transient
+  protected Integer height;
+
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "description", length = 255)
+  protected String description;
+
+
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "id", length = 255, insertable = false, updatable = false)
+  protected String id;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<ListField> ims;
+
+
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "updated_at")
+  @Temporal(TemporalType.TIMESTAMP)
+  protected Date updated;
+
+  /**
+   *
+   */
+  @Transient
+  protected String screenshotUrl;
+  
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "external_thumbnail", length = 255)
+  protected String thumbnailUrl;
+
+
+  /**
+   *
+   */
+  @Transient
+  protected Long utcOffset;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<String> tags;
+
+  // Note: Not in the opensocial js person object directly
+  @Transient
+  private boolean isOwner = false;
+
+  public DocumentDb() {
+  }
+
+  public DocumentDb(String id, String displayName) {
+    this.id = id;
+    this.displayName = displayName;
+  }
+
+  public String getDocumentType() {
+	  return documentType;
+  }
+
+  public void setDocumentType(String documentType) {
+	  this.documentType = documentType;
+  }
+	  
+  public String getDocumentEntity() {
+    return documentEntity;
+  }
+
+  public void setDocumentEntity(String documentEntity) {
+    this.documentEntity = documentEntity;
+  }
+
+  public String getAuthor() {
+    return author;
+  }
+
+  public void setAuthor(String author) {
+    this.author = author;
+  }
+
+  public Integer getHeight() {
+    return height;
+  }
+
+  public void setHeight(Integer height) {
+    this.height = height;
+  }
+
+  public String getScreenshotUrl() {
+    return screenshotUrl;
+  }
+
+  public void setScreenshotUrl(String screenshotUrl) {
+    this.screenshotUrl = screenshotUrl;
+  }
+  
+  public String getProfileUrl() {
+    return "path_url"+String.valueOf(objectId);     
+  }
+
+  public void setProfileUrl(String profileUrl) {
+    
+  }
+  
+  public String getThumbnailUrl() {
+    String pic = picture;
+    if (pic == null || pic.equals("")) {
+      return "path_url/asset_thumb.png";
+    }
+    
+    return "path_url/picture/"+String.valueOf(objectId)+"/thumb/"+pic;        
+  }
+
+  public void setThumbnailUrl(String thumbnailUrl) {
+    this.thumbnailUrl = thumbnailUrl;
+  }
+
+  public String getAuthorEmail() {
+    return authorEmail;
+  }
+
+  public void setAuthorEmail(String authorEmail) {
+    this.authorEmail = authorEmail;
+  }                               
+
+  public List<String> getTags() {
+    return tags;
+  }
+
+  public void setTags(List<String> tags) {
+    this.tags = tags;
+  }
+
+  public String getParentId() {
+    return this.parentId;
+  }
+
+  public void setParentId(String parentId) {
+    this.parentId = parentId;
+  }
+  
+  public String getParentType() {
+	  if(this.parentType.equals("User")){
+		  return "@person";
+	  }else{
+		  return "@space";
+	  }
+  }
+
+  public void setParentType(String parentType) {
+    this.parentType = parentType;
+  }
+  
+  public String getName() {
+    return this.name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  
+  public String getId() {
+    return id;
+  }
+
+  public void setId(String id) {
+    this.id = id;
+  }
+
+  public List<ListField> getIms() {
+    return ims;
+  }
+
+  public void setIms(List<ListField> ims) {
+    this.ims = ims;
+  }
+
+  public Date getUpdated() {
+    if (updated == null) {
+      return null;
+    }
+    return new Date(updated.getTime());
+  }
+
+  public void setUpdated(Date updated) {
+    if (updated == null) {
+      this.updated = null;
+    } else {
+      this.updated = new Date(updated.getTime());
+    }
+  }
+
+
+  public String getDescription() {
+    return description;
+  }
+
+  public void setDescription(String description) {
+    this.description = description;
+  }
+  
+  public Long getUtcOffset() {
+    return utcOffset;
+  }
+
+  public void setUtcOffset(Long utcOffset) {
+    this.utcOffset = utcOffset;
+  }
+
+  public boolean getIsOwner() {
+    return isOwner;
+  }
+
+  public void setIsOwner(boolean isOwner) {
+    this.isOwner = isOwner;
+  }
+
+  // Proxied fields
+
+
+
+  private <T extends ListField> T getListFieldWithType(String type, List<T> list) {
+    if (list != null) {
+      for (T url : list) {
+        if (type.equalsIgnoreCase(url.getType())) {
+          return url;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private <T extends ListField> List<T> addListField(T field, List<T> list) {
+    if (list == null) {
+      list = Lists.newArrayList();
+    }
+    list.add(field);
+    return list;
+  }
+
+  /**
+   * @return the objectId
+   */
+  public long getObjectId() {
+    return Long.parseLong(id);
+  }
+
+  @PrePersist
+  public void populateDbFields() {
+
+
+  }
+
+  @PostLoad
+  public void loadTransientFields() {
+
+
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.apache.shindig.social.opensocial.model.Person#getDisplayName()
+   */
+  public String getDisplayName() {
+    return displayName;
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.apache.shindig.social.opensocial.model.Person#setDisplayName(java.lang.String)
+   */
+  public void setDisplayName(String displayName) {
+    this.displayName = displayName;
+  }
+
+  public static FilterCapability getFilterCapability() {
+    return FILTER_CAPABILITY;
+
+  }
+
+  /** {@inheritDoc} */
+  public Map<String, ? extends Object> getAppData()
+  {
+    return null;
+  }
+
+  /** {@inheritDoc} */
+  public void setAppData( Map<String, ? extends Object> appData )
+  {
+  }
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/AddressDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/AddressDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/AddressDb.java	(working copy)
@@ -36,7 +36,9 @@
 import javax.persistence.OneToMany;
 import javax.persistence.Table;
 import javax.persistence.Version;
+import javax.persistence.Transient;
 
+
 import java.util.List;
 
 /**
@@ -81,7 +83,8 @@
   /**
    * People may be at this address, this is a list of people who are currently at this address.
    */
-  @OneToMany(targetEntity = PersonDb.class, mappedBy = "currentLocation")
+  // @OneToMany(targetEntity = PersonDb.class, mappedBy = "currentLocation")
+  @Transient
   private List<Person> atLocation;
 
   /**
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/PermissionDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/PermissionDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/PermissionDb.java	(revision 0)
@@ -0,0 +1,213 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa;
+
+import static javax.persistence.CascadeType.ALL;
+import static javax.persistence.CascadeType.MERGE;
+import static javax.persistence.CascadeType.PERSIST;
+import static javax.persistence.CascadeType.REFRESH;
+import static javax.persistence.GenerationType.IDENTITY;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
+import org.apache.shindig.social.opensocial.jpa.api.DbObject;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.FilterOperation;
+import org.apache.shindig.social.opensocial.model.Account;
+import org.apache.shindig.social.opensocial.model.Address;
+import org.apache.shindig.social.opensocial.model.BodyType;
+import org.apache.shindig.social.opensocial.model.Drinker;
+import org.apache.shindig.social.opensocial.model.ListField;
+import org.apache.shindig.social.opensocial.model.LookingFor;
+import org.apache.shindig.social.opensocial.model.Name;
+import org.apache.shindig.social.opensocial.model.NetworkPresence;
+import org.apache.shindig.social.opensocial.model.Organization;
+import org.apache.shindig.social.opensocial.model.Person;
+import org.apache.shindig.social.opensocial.model.Application;
+import org.apache.shindig.social.opensocial.model.Smoker;
+import org.apache.shindig.social.opensocial.model.Url;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.Basic;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.JoinTable;
+import javax.persistence.ManyToMany;
+import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
+import javax.persistence.OneToMany;
+import javax.persistence.PostLoad;
+import javax.persistence.PrePersist;
+import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+import javax.persistence.Transient;
+import javax.persistence.Version;
+
+/**
+ * Default Implementation of the Person object in the org.apache.shindig.social.opensocial.jpa.
+ */
+@Entity
+@Table(name = "mdl_role_assignments") // implements moodle role assignments table
+public class PermissionDb implements DbObject {
+  
+  // roleid = (1,2,3) is course owner in Moodle
+  // mc.instanceId = 0 corresponds to the main (admin) contextid of moodle
+  /**
+   * Only course teachers and managers are considered to be owners
+   * Site administrators are not the owners of widgetspaces
+   * If we want to add them as owners we should append mdl_config -> siteadmins
+   * to PersonServiceDb.java (getPerson) -> owners variable
+   */
+  public static final String JPQL_OWNERS_BY_MOODLE_COURSE = "select distinct p.userId from PermissionDb p where p.roleId in ('1','2','3') and p.contextId in (select distinct mc.id from MoodleContextDb mc where mc.instanceId = '0' or mc.instanceId = '"; // append moodle course id
+  
+  /**
+   * The internal object ID used for references to this object. Should be generated by the
+   * underlying storage mechanism
+   */
+  @Id
+  @GeneratedValue(strategy = IDENTITY)
+  @Column(name = "id")
+  private long objectId;
+  
+  /**
+   * The internal itemId and itemType used for references to the item of a widget.
+   */
+  
+  @Basic
+  @Column(name = "roleid", length = 255)
+  private String roleId;
+  
+  @Basic
+  @Column(name = "contextid", length = 255)
+  protected String contextId;
+
+  @Basic
+  @Column(name = "userid", length = 255)
+  protected String userId;
+  
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "id", length = 255, insertable = false, updatable = false)
+  protected String id;
+
+  // Note: Not in the opensocial js person object directly
+  @Transient
+  private boolean isOwner = false;
+
+  public PermissionDb() {
+  }
+
+  public String getUserId() {
+    return userId;
+  }
+
+  public void setUserId(String userId) {
+    this.userId = userId;
+  }                               
+
+  public String getRoleId() {
+    return roleId;
+  }
+
+  public void setRoleId(String roleId) {
+    this.roleId = roleId;
+  }                               
+  
+  public String getContextId() {
+	  return contextId;
+  }
+
+  public void setContextId(String contextId) {
+    this.contextId = contextId;
+  }
+    
+  public String getId() {
+    return id;
+  }
+
+  public void setId(String id) {
+    this.id = id;
+  }
+
+  public boolean getIsOwner() {
+    return isOwner;
+  }
+
+  public void setIsOwner(boolean isOwner) {
+    this.isOwner = isOwner;
+  }
+
+  // Proxied fields
+
+
+
+  private <T extends ListField> T getListFieldWithType(String type, List<T> list) {
+    if (list != null) {
+      for (T url : list) {
+        if (type.equalsIgnoreCase(url.getType())) {
+          return url;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private <T extends ListField> List<T> addListField(T field, List<T> list) {
+    if (list == null) {
+      list = Lists.newArrayList();
+    }
+    list.add(field);
+    return list;
+  }
+
+  /**
+   * @return the objectId
+   */
+  public long getObjectId() {
+    return Long.parseLong(id);
+  }
+
+  @PrePersist
+  public void populateDbFields() {
+
+
+  }
+
+  @PostLoad
+  public void loadTransientFields() {
+
+
+  }
+
+}
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/BodyTypeDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/BodyTypeDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/BodyTypeDb.java	(working copy)
@@ -34,7 +34,9 @@
 import javax.persistence.OneToMany;
 import javax.persistence.Table;
 import javax.persistence.Version;
+import javax.persistence.Transient;
 
+
 import java.util.List;
 
 /**
@@ -72,7 +74,8 @@
   @Column(name = "version")
   protected long version;
 
-  @OneToMany(targetEntity = PersonDb.class, mappedBy = "bodyType")
+  // @OneToMany(targetEntity = PersonDb.class, mappedBy = "bodyType")
+  @Transient
   private List<Person> persons;
 
   /**
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/ApplicationDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/ApplicationDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/ApplicationDb.java	(working copy)
@@ -17,108 +17,484 @@
  */
 package org.apache.shindig.social.opensocial.jpa;
 
+import static javax.persistence.CascadeType.ALL;
+import static javax.persistence.CascadeType.MERGE;
+import static javax.persistence.CascadeType.PERSIST;
+import static javax.persistence.CascadeType.REFRESH;
 import static javax.persistence.GenerationType.IDENTITY;
 
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
 import org.apache.shindig.social.opensocial.jpa.api.DbObject;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.FilterOperation;
+import org.apache.shindig.social.opensocial.model.Account;
+import org.apache.shindig.social.opensocial.model.Address;
+import org.apache.shindig.social.opensocial.model.BodyType;
+import org.apache.shindig.social.opensocial.model.Drinker;
 import org.apache.shindig.social.opensocial.model.ListField;
+import org.apache.shindig.social.opensocial.model.LookingFor;
+import org.apache.shindig.social.opensocial.model.Name;
+import org.apache.shindig.social.opensocial.model.NetworkPresence;
+import org.apache.shindig.social.opensocial.model.Organization;
+import org.apache.shindig.social.opensocial.model.Person;
+import org.apache.shindig.social.opensocial.model.Application;
+import org.apache.shindig.social.opensocial.model.Smoker;
+import org.apache.shindig.social.opensocial.model.Url;
 
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
 import javax.persistence.Basic;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
-import javax.persistence.MapKey;
+import javax.persistence.JoinColumn;
+import javax.persistence.JoinTable;
+import javax.persistence.ManyToMany;
+import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
 import javax.persistence.OneToMany;
+import javax.persistence.PostLoad;
+import javax.persistence.PrePersist;
 import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+import javax.persistence.Transient;
 import javax.persistence.Version;
 
-import java.util.Map;
-
 /**
- * Stores information about applications
+ * Default Implementation of the Person object in the org.apache.shindig.social.opensocial.jpa.
  */
 @Entity
-@Table(name = "application")
-public class ApplicationDb implements DbObject {
+@Table(name = "mdl_widgetspace_gadgets")
+@NamedQueries(value = {
+    @NamedQuery(name = ApplicationDb.FINDBY_WIDGETID,
+        query = "select w from ApplicationDb w where w.id = :id "),
+    @NamedQuery(name = ApplicationDb.FINDBY_LIKE_WIDGETID,
+        query = "select w from ApplicationDb w where w.id like :id") })
+public class ApplicationDb implements Application, DbObject {
+
+  public static final String FINDBY_WIDGETID = "q.widget.findbywidgetid";
+
+  public static final String PARAM_WIDGETID = "id";
+
+  public static final String FINDBY_LIKE_WIDGETID = "q.widget.findbylikewidgetid";
+
+  private static final String INTERESTS_PROPERTY = "interest";
+
+  private static final Map<String, FilterSpecification> FILTER_COLUMNS =
+    new HashMap<String, FilterSpecification>();
+
+  private static final FilterOperation[] ALL_FILTEROPTIONS = new FilterOperation[] {
+      FilterOperation.equals, FilterOperation.contains, FilterOperation.present,
+      FilterOperation.startsWith };
+  private static final FilterOperation[] NUMERIC_FILTEROPTIONS = new FilterOperation[] {
+      FilterOperation.equals, FilterOperation.present };
+  @SuppressWarnings("unused")
+  private static final FilterOperation[] EQUALS_FILTEROPTIONS =
+    new FilterOperation[] { FilterOperation.equals };
+
+  static {
+    FILTER_COLUMNS.put("displayName", new FilterSpecification("displayName", ALL_FILTEROPTIONS));
+
+    // the following are special operations which are accepted, but work differently
+    FILTER_COLUMNS.put("topFriends", new FilterSpecification());
+    FILTER_COLUMNS.put("hasApp", new FilterSpecification());
+  }
+
+  private static final FilterCapability FILTER_CAPABILITY = new FilterCapability() {
+    /**
+     * {@inheritDoc}
+     */
+    public String findFilterableProperty(String fieldName, FilterOperation filterOperation) {
+      FilterSpecification spec = FILTER_COLUMNS.get(fieldName);
+      if (spec != null) {
+        return spec.translateProperty(filterOperation);
+      }
+      return null;
+    }
+
+  };
+
+  public static final String JPQL_FINDALLPERSON = null;
+
+  // TODO The commented out query supports sorting by friend.score but needs a join with FriendDb which returns duplicates.
+  // Using 'group by' to avoid duplicates doesn't work in HSQLDB or Derby - causes a "Not in aggregate function or group by clause" jdbc exception.
+  // public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p join FriendDb f on p.objectId = f.friend.objectId where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+  public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
+
+  public static final Object JPQL_FINDPERSON_BY_GROUP = null;
+
+  public static final Object JPQL_FINDWIDGET = "select w from ApplicationDb w where ";
+  public static final Object JPQL_FINDWIDGETS = "select w from ApplicationDb w where ";
+
   /**
    * The internal object ID used for references to this object. Should be generated by the
    * underlying storage mechanism
    */
   @Id
   @GeneratedValue(strategy = IDENTITY)
-  @Column(name = "oid")
-  protected long objectId;
+  @Column(name = "id")
+  private long objectId;
+  
+  /**
+   * The internal parentId and parentType used for references to the parent of a widget.
+   */
+  @Basic
+  @Column(name = "widgetspaceid", length = 255)
+  private String parentId;
+  
+  @Transient
+  protected String parentType;
 
   /**
    * An optimistic locking field.
    */
-  @Version
-  @Column(name = "version")
-  protected long version;
 
+  @Basic
+  @Column(name = "url", length = 255)
+  protected String appUrl;
+  
+  @Transient
+  protected String appType;
 
+  @Transient
+  protected String author;
+  
+  @Transient
+  protected String authorEmail;
+
+  @Basic
+  @Column(name = "name", length = 255)
+  private String displayName;
+
+  @Basic
+  @Column(name = "name", length = 255, insertable = false, updatable = false)
+  private String name;
+  
+  @Basic
+  @Column(name = "thumbnail")
+  protected String picture;
+  
+  
   /**
-   * The application has properties.
+   *
    */
-  @OneToMany(targetEntity = ApplicationPropertyDb.class, mappedBy = "application")
-  @MapKey(name = "type")
-  protected Map<String, ListField> properties;
+  @Basic
+  @Column(name = "height")
+  protected Integer height;
 
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "description", length = 255)
+  protected String description;
 
+
   /**
-   * Each Application has an Id
+   *
    */
   @Basic
-  @Column(name = "id", length = 255)
+  @Column(name = "id", length = 255, insertable = false, updatable = false)
   protected String id;
 
+  /**
+   *
+   */
+  @Transient
+  protected List<ListField> ims;
 
+
   /**
-   * @return the properties
+   *
    */
-  public Map<String, ListField> getProperties() {
-    return properties;
-  }
+  // @Basic
+  // @Column(name = "timemodified")
+  // @Temporal(TemporalType.TIMESTAMP)
+  @Transient
+  protected Date updated;
 
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "screenshot")
+  protected String screenshotUrl;
+  
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "thumbnail", length = 255, insertable = false, updatable = false)
+  protected String thumbnailUrl;
 
+
   /**
-   * @param properties the properties to set
+   *
    */
-  public void setProperties(Map<String, ListField> properties) {
-    this.properties = properties;
+  @Transient
+  protected Long utcOffset;
+
+  /**
+   *
+   */
+  @Transient
+  protected List<String> tags;
+
+  // Note: Not in the opensocial js person object directly
+  @Transient
+  private boolean isOwner = false;
+
+  public ApplicationDb() {
   }
 
+  public ApplicationDb(String id, String displayName) {
+    this.id = id;
+    this.displayName = displayName;
+  }
 
-  /**
-   * @return the id
-   */
+  public String getAppType() {
+	  return appType;
+  }
+
+  public void setAppType(String appType) {
+	  this.appType = appType;
+  }
+	  
+  public String getAppUrl() {
+    return appUrl;
+  }
+
+  public void setAppUrl(String appUrl) {
+    this.appUrl = appUrl;
+  }
+
+  public String getAuthor() {
+    return author;
+  }
+
+  public void setAuthor(String author) {
+    this.author = author;
+  }
+
+  public Integer getHeight() {
+    return height;
+  }
+
+  public void setHeight(Integer height) {
+    this.height = height;
+  }
+
+  public String getScreenshotUrl() {
+    return screenshotUrl;
+  }
+
+  public void setScreenshotUrl(String screenshotUrl) {
+    this.screenshotUrl = screenshotUrl;
+  }
+  
+  public String getProfileUrl() {
+    return "path_url"+String.valueOf(objectId);     
+  }
+
+  public void setProfileUrl(String profileUrl) {
+
+  }
+
+  public String getThumbnailUrl() {
+    String pic = picture;
+    if (pic == null || pic.equals("")) {
+      return "path_url/widget_thumb.png";
+    }
+    
+    return "path_url/picture/"+String.valueOf(objectId)+"/thumb/"+pic;        
+  }
+
+  public void setThumbnailUrl(String thumbnailUrl) {
+    this.thumbnailUrl = thumbnailUrl;
+  }
+
+  public String getAuthorEmail() {
+    return authorEmail;
+  }
+
+  public void setAuthorEmail(String authorEmail) {
+    this.authorEmail = authorEmail;
+  }                               
+
+  public List<String> getTags() {
+    return tags;
+  }
+
+  public void setTags(List<String> tags) {
+    this.tags = tags;
+  }
+
+  public String getParentId() {
+    return this.parentId;
+  }
+
+  public void setParentId(String parentId) {
+    this.parentId = parentId;
+  }
+  
+  public String getParentType() {
+    return "@space";
+  }
+
+  public void setParentType(String parentType) {
+    this.parentType = parentType;
+  }
+  
+  public String getName() {
+    return this.name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  
   public String getId() {
     return id;
   }
 
-
-  /**
-   * @param id the id to set
-   */
   public void setId(String id) {
     this.id = id;
   }
 
+  public List<ListField> getIms() {
+    return ims;
+  }
 
-  /**
-   * @return the version
-   */
-  public long getVersion() {
-    return version;
+  public void setIms(List<ListField> ims) {
+    this.ims = ims;
   }
 
+  public Date getUpdated() {
+    if (updated == null) {
+      return null;
+    }
+    return new Date(updated.getTime());
+  }
 
+  public void setUpdated(Date updated) {
+    if (updated == null) {
+      this.updated = null;
+    } else {
+      this.updated = new Date(updated.getTime());
+    }
+  }
+
+
+  public String getDescription() {
+    return description;
+  }
+
+  public void setDescription(String description) {
+    this.description = description;
+  }
+  
+  public Long getUtcOffset() {
+    return utcOffset;
+  }
+
+  public void setUtcOffset(Long utcOffset) {
+    this.utcOffset = utcOffset;
+  }
+
+  public boolean getIsOwner() {
+    return isOwner;
+  }
+
+  public void setIsOwner(boolean isOwner) {
+    this.isOwner = isOwner;
+  }
+
+  // Proxied fields
+
+
+
+  private <T extends ListField> T getListFieldWithType(String type, List<T> list) {
+    if (list != null) {
+      for (T url : list) {
+        if (type.equalsIgnoreCase(url.getType())) {
+          return url;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private <T extends ListField> List<T> addListField(T field, List<T> list) {
+    if (list == null) {
+      list = Lists.newArrayList();
+    }
+    list.add(field);
+    return list;
+  }
+
   /**
    * @return the objectId
    */
   public long getObjectId() {
-    return objectId;
+    return Long.parseLong(id);
   }
 
+  @PrePersist
+  public void populateDbFields() {
 
+
+  }
+
+  @PostLoad
+  public void loadTransientFields() {
+
+
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.apache.shindig.social.opensocial.model.Person#getDisplayName()
+   */
+  public String getDisplayName() {
+    return displayName;
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.apache.shindig.social.opensocial.model.Person#setDisplayName(java.lang.String)
+   */
+  public void setDisplayName(String displayName) {
+    this.displayName = displayName;
+  }
+
+  public static FilterCapability getFilterCapability() {
+    return FILTER_CAPABILITY;
+
+  }
+
+  /** {@inheritDoc} */
+  public Map<String, ? extends Object> getAppData()
+  {
+    return null;
+  }
+
+  /** {@inheritDoc} */
+  public void setAppData( Map<String, ? extends Object> appData )
+  {
+  }
 }
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/PersonDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/PersonDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/PersonDb.java	(working copy)
@@ -74,7 +74,7 @@
  * Default Implementation of the Person object in the org.apache.shindig.social.opensocial.jpa.
  */
 @Entity
-@Table(name = "person")
+@Table(name = "mdl_user")
 @NamedQueries(value = {
     @NamedQuery(name = PersonDb.FINDBY_PERSONID,
         query = "select p from PersonDb p where p.id = :id "),
@@ -190,7 +190,9 @@
   // Using 'group by' to avoid duplicates doesn't work in HSQLDB or Derby - causes a "Not in aggregate function or group by clause" jdbc exception.
   // public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p join FriendDb f on p.objectId = f.friend.objectId where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
   public static final String JPQL_FINDPERSON_BY_FRIENDS = "select p from PersonDb p where p.objectId in (select f.friend.objectId from PersonDb p, FriendDb f where p.objectId = f.person.objectId and ";
-
+  public static final String JPQL_FINDPERSON_BY_PERMISSIONS = "select a from PersonDb a where a.objectId in (select p.userId from PermissionDb p where p.status = 'joined' and ";
+  public static final String JPQL_PERMISSIONS = "select p.userId from PermissionDb p where p.status = 'joined' and ";
+  
   public static final Object JPQL_FINDPERSON_BY_GROUP = null;
 
   public static final Object JPQL_FINDPERSON = "select p from PersonDb p where ";
@@ -201,38 +203,62 @@
    */
   @Id
   @GeneratedValue(strategy = IDENTITY)
-  @Column(name = "oid")
+  @Column(name = "id")
   private long objectId;
 
   /**
-   * An optimistic locking field.
+   * First Name
    */
-  @Version
-  @Column(name = "version")
-  protected long version;
+  @Basic
+  @Column(name = "firstname")
+  private String firstName;
 
+  /**
+   * Last Name
+   */
   @Basic
-  @Column(name = "about_me", length = 255)
+  @Column(name = "lastname")
+  private String lastName;
+  
+  /**
+   * Description
+   */
+  @Basic
+  @Column(name = "description", length = 255)
   protected String aboutMe;
 
-  @OneToMany(targetEntity = PersonPropertyDb.class, mappedBy = "person", cascade = ALL)
+
+  /**
+   * An optimistic locking field.
+   */
+  // @Version
+  // @Column(name = "version")
+  @Transient
+  protected long version;
+
+  // @OneToMany(targetEntity = PersonPropertyDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<PersonPropertyDb> properties = Lists.newArrayList();
 
-  @OneToMany(targetEntity = PersonAccountDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = PersonAccountDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<Account> accounts;
 
   @Transient
   protected List<String> activities;
 
-  @OneToMany(targetEntity = PersonAddressDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = PersonAddressDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<Address> addresses;
 
-  @Basic
-  @Column(name = "age")
+  // @Basic
+  // @Column(name = "age")
+  @Transient
   protected Integer age;
 
-  @ManyToOne(targetEntity = BodyTypeDb.class, cascade = ALL)
-  @JoinColumn(name = "body_type_id", referencedColumnName = "oid")
+  // @ManyToOne(targetEntity = BodyTypeDb.class, cascade = ALL)
+  // @JoinColumn(name = "body_type_id", referencedColumnName = "oid")
+  @Transient
   protected BodyType bodyType;
 
   @Transient
@@ -241,57 +267,65 @@
   @Transient
   protected List<String> cars;
 
-  @Basic
-  @Column(name = "children", length = 255)
+  // @Basic
+  // @Column(name = "children", length = 255)
+  @Transient
   protected String children;
 
   /**
    *
    */
-  @ManyToOne(targetEntity = AddressDb.class, cascade = { PERSIST, MERGE, REFRESH })
-  @JoinColumn(name = "address_id", referencedColumnName = "oid")
+  // @ManyToOne(targetEntity = AddressDb.class, cascade = { PERSIST, MERGE, REFRESH })
+  // @JoinColumn(name = "address_id", referencedColumnName = "oid")
+  @Transient
   protected Address currentLocation;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "birthday")
-  @Temporal(TemporalType.DATE)
+  // @Basic
+  // @Column(name = "birthday")
+  // @Temporal(TemporalType.DATE)
+  @Transient
   protected Date birthday;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "drinker", length = 255)
+  // @Basic
+  // @Column(name = "drinker", length = 255)
+  @Transient
   protected String drinkerDb;
 
   @Transient
   protected Enum<Drinker> drinker;
 
-  @Basic
-  @Column(name = "display_name", length = 255)
+  // @Basic
+  // @Column(name = "display_name", length = 255)
+  @Transient
   private String displayName;
 
   /**
    *
    */
-  @OneToMany(targetEntity = EmailDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = EmailDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<ListField> emails;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "ethnicity", length = 255)
+  // @Basic
+  // @Column(name = "ethnicity", length = 255)
+  @Transient
   protected String ethnicity;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "fashion", length = 255)
+  // @Basic
+  // @Column(name = "fashion", length = 255)
+  @Transient
   protected String fashion;
 
   /**
@@ -303,8 +337,9 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "gender", length = 255)
+  // @Basic
+  // @Column(name = "gender", length = 255)
+  @Transient
   protected String genderDb;
 
   @Transient
@@ -313,8 +348,9 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "happiest_when", length = 255)
+  // @Basic
+  // @Column(name = "happiest_when", length = 255)
+  @Transient
   protected String happiestWhen;
 
   /**
@@ -332,21 +368,23 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "humor", length = 255)
+  // @Basic
+  // @Column(name = "humor", length = 255)
+  @Transient
   protected String humor;
 
   /**
    *
    */
   @Basic
-  @Column(name = "person_id", length = 255)
+  @Column(name = "id", length = 255, insertable = false, updatable = false)
   protected String id;
 
   /**
    *
    */
-  @OneToMany(targetEntity = ImDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = ImDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<ListField> ims;
 
   /**
@@ -358,8 +396,9 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "job_interests", length = 255)
+  // @Basic
+  // @Column(name = "job_interests", length = 255)
+  @Transient
   protected String jobInterests;
 
   /**
@@ -371,16 +410,18 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "updated")
-  @Temporal(TemporalType.TIMESTAMP)
+  // @Basic
+  // @Column(name = "updated")
+  // @Temporal(TemporalType.TIMESTAMP)
+  @Transient
   protected Date updated;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "living_arrangement", length = 255)
+  // @Basic
+  // @Column(name = "living_arrangement", length = 255)
+  @Transient
   protected String livingArrangement;
 
   /**
@@ -405,15 +446,17 @@
   /**
    *
    */
-  @ManyToOne(targetEntity = NameDb.class, cascade = ALL)
-  @JoinColumn(name = "name_id", referencedColumnName = "oid")
+  // @ManyToOne(targetEntity = NameDb.class, cascade = ALL)
+  // @JoinColumn(name = "name_id", referencedColumnName = "oid")
+  @Transient
   protected Name name;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "network_presence", length = 255)
+  // @Basic
+  // @Column(name = "network_presence", length = 255)
+  @Transient
   protected String networkPresenceDb;
 
   @Transient
@@ -423,41 +466,48 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "nickname", length = 255)
+  // @Basic
+  // @Column(name = "nickname", length = 255)
+  @Transient
   protected String nickname;
 
   /**
    *
    */
-  @OneToMany(targetEntity = PersonOrganizationDb.class, mappedBy = "person", cascade = { PERSIST,
-      MERGE, REFRESH })
+  // @OneToMany(targetEntity = PersonOrganizationDb.class, mappedBy = "person", cascade = { PERSIST,
+      // MERGE, REFRESH })
+  @Transient
   protected List<Organization> organizations;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "pets", length = 255)
+  // @Basic
+  // @Column(name = "pets", length = 255)
+  @Transient
   protected String pets;
 
   /**
    *
    */
-  @OneToMany(targetEntity = PhoneDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = PhoneDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<ListField> phoneNumbers;
 
   /**
    *
    */
-  @OneToMany(targetEntity = PhotoDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = PhotoDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<ListField> photos;
-  @Basic
-  @Column(name = "political_views", length = 255)
+  // @Basic
+  // @Column(name = "political_views", length = 255)
+  @Transient
   protected String politicalViews;
 
-  @Basic
-  @Column(name = "preferredUsername", length = 255)
+  // @Basic
+  // @Column(name = "preferredUsername", length = 255)
+  @Transient
   protected String preferredUsername;
 
   /**
@@ -481,43 +531,49 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "relationship_status", length = 255)
+  // @Basic
+  // @Column(name = "relationship_status", length = 255)
+  @Transient
   protected String relationshipStatus;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "religion", length = 255)
+  // @Basic
+  // @Column(name = "religion", length = 255)
+  @Transient
   protected String religion;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "romance", length = 255)
+  // @Basic
+  // @Column(name = "romance", length = 255)
+  @Transient
   protected String romance;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "scared_of", length = 255)
+  // @Basic
+  // @Column(name = "scared_of", length = 255)
+  @Transient
   protected String scaredOf;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "sexual_orientation", length = 255)
+  // @Basic
+  // @Column(name = "sexual_orientation", length = 255)
+  @Transient
   protected String sexualOrientation;
 
   /**
    *
    */
-  @Basic
-  @Column(name = "smoker", length = 255)
+  // @Basic
+  // @Column(name = "smoker", length = 255)
+  @Transient
   protected String smokerDb;
 
   @Transient
@@ -532,8 +588,9 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "status", length = 255)
+  // @Basic
+  // @Column(name = "status", length = 255)
+  @Transient
   protected String status;
 
   /**
@@ -545,8 +602,9 @@
   /**
    *
    */
-  @Basic
-  @Column(name = "utc_offset")
+  // @Basic
+  // @Column(name = "utc_offset")
+  @Transient
   protected Long utcOffset;
 
   /**
@@ -570,7 +628,8 @@
   /**
    *
    */
-  @OneToMany(targetEntity = UrlDb.class, mappedBy = "person", cascade = ALL)
+  // @OneToMany(targetEntity = UrlDb.class, mappedBy = "person", cascade = ALL)
+  @Transient
   protected List<Url> urls;
 
   // Note: Not in the opensocial js person object directly
@@ -586,10 +645,11 @@
    * person_application.person_id points to person.oid and person_application.application_id points
    * to application.oid.
    */
-  @ManyToMany(targetEntity = ApplicationDb.class)
-  @JoinTable(name = "person_application",
-      joinColumns = @JoinColumn(name = "person_id", referencedColumnName = "oid"),
-      inverseJoinColumns = @JoinColumn(name = "application_id", referencedColumnName = "oid"))
+  // @ManyToMany(targetEntity = ApplicationDb.class)
+  // @JoinTable(name = "person_application",
+      // joinColumns = @JoinColumn(name = "person_id", referencedColumnName = "oid"),
+      // inverseJoinColumns = @JoinColumn(name = "application_id", referencedColumnName = "oid"))
+  @Transient
   protected List<ApplicationDb> applictions;
 
   public PersonDb() {
@@ -1212,64 +1272,64 @@
   @PostLoad
   public void loadTransientFields() {
 
-    drinkerDb = drinker.toString();
-    genderDb = gender.toString();
-    networkPresenceDb = networkPresence.toString();
-    smokerDb = smoker.toString();
+    // drinkerDb = drinker.toString();
+    // genderDb = gender.toString();
+    // networkPresenceDb = networkPresence.toString();
+    // smokerDb = smoker.toString();
+    // 
+    // drinker = new EnumDb<Drinker>(Drinker.valueOf(drinkerDb));
+    // gender = Gender.valueOf(genderDb);
+    // networkPresence = new EnumDb<NetworkPresence>(NetworkPresence.valueOf(networkPresenceDb));
+    // smoker = new EnumDb<Smoker>(Smoker.valueOf(smokerDb));
+    // 
+    // List<String> lookingFor = Lists.newArrayList();
+    // this.activities = Lists.newArrayList();
+    // this.books = Lists.newArrayList();
+    // this.cars = Lists.newArrayList();
+    // this.food = Lists.newArrayList();
+    // this.heroes = Lists.newArrayList();
+    // this.interests = Lists.newArrayList();
+    // this.languagesSpoken = Lists.newArrayList();
+    // this.movies = Lists.newArrayList();
+    // this.music = Lists.newArrayList();
+    // this.quotes = Lists.newArrayList();
+    // this.sports = Lists.newArrayList();
+    // this.tags = Lists.newArrayList();
+    // this.turnOffs = Lists.newArrayList();
+    // this.turnOns = Lists.newArrayList();
+    // this.tvShows = Lists.newArrayList();
+    // 
+    // Map<String, List<String>> toSave = Maps.newHashMap();
+    // 
+    // toSave.put(LOOKING_FOR_PROPERTY, lookingFor);
+    // toSave.put(ACTIVITIES_PROPERTY, this.activities);
+    // toSave.put(BOOKS_PROPERTY, this.books);
+    // toSave.put(CARS_PROPERTY, this.cars);
+    // toSave.put(FOOD_PROPERTY, this.food);
+    // toSave.put(HEROES_PROPERTY, this.heroes);
+    // toSave.put(INTERESTS_PROPERTY, this.interests);
+    // toSave.put(LANGUAGES_PROPERTY, this.languagesSpoken);
+    // toSave.put(MOVIES_PROPERTY, this.movies);
+    // toSave.put(MUSIC_PROPERTY, this.music);
+    // toSave.put(QUOTES_PROPERTY, this.quotes);
+    // toSave.put(SPORTS_PROPERTY, this.sports);
+    // toSave.put(TAGS_PROPERTY, this.tags);
+    // toSave.put(TURNOFFS_PROPERTY, this.turnOffs);
+    // toSave.put(TURNONS_PROPERTY, this.turnOns);
+    // toSave.put(TVSHOWS_PROPERTY, this.tvShows);
+    // 
+    // for (PersonPropertyDb pp : properties) {
+    //   List<String> l = toSave.get(pp.type);
+    //   if (l != null) {
+    //     l.add(pp.getValue());
+    //   }
+    // }
+    // 
+    // this.lookingFor = Lists.newArrayList();
+    // for (String lf : lookingFor) {
+    //   this.lookingFor.add(new EnumDb<LookingFor>(LookingFor.valueOf(lf)));
+    // }
 
-    drinker = new EnumDb<Drinker>(Drinker.valueOf(drinkerDb));
-    gender = Gender.valueOf(genderDb);
-    networkPresence = new EnumDb<NetworkPresence>(NetworkPresence.valueOf(networkPresenceDb));
-    smoker = new EnumDb<Smoker>(Smoker.valueOf(smokerDb));
-
-    List<String> lookingFor = Lists.newArrayList();
-    this.activities = Lists.newArrayList();
-    this.books = Lists.newArrayList();
-    this.cars = Lists.newArrayList();
-    this.food = Lists.newArrayList();
-    this.heroes = Lists.newArrayList();
-    this.interests = Lists.newArrayList();
-    this.languagesSpoken = Lists.newArrayList();
-    this.movies = Lists.newArrayList();
-    this.music = Lists.newArrayList();
-    this.quotes = Lists.newArrayList();
-    this.sports = Lists.newArrayList();
-    this.tags = Lists.newArrayList();
-    this.turnOffs = Lists.newArrayList();
-    this.turnOns = Lists.newArrayList();
-    this.tvShows = Lists.newArrayList();
-
-    Map<String, List<String>> toSave = Maps.newHashMap();
-
-    toSave.put(LOOKING_FOR_PROPERTY, lookingFor);
-    toSave.put(ACTIVITIES_PROPERTY, this.activities);
-    toSave.put(BOOKS_PROPERTY, this.books);
-    toSave.put(CARS_PROPERTY, this.cars);
-    toSave.put(FOOD_PROPERTY, this.food);
-    toSave.put(HEROES_PROPERTY, this.heroes);
-    toSave.put(INTERESTS_PROPERTY, this.interests);
-    toSave.put(LANGUAGES_PROPERTY, this.languagesSpoken);
-    toSave.put(MOVIES_PROPERTY, this.movies);
-    toSave.put(MUSIC_PROPERTY, this.music);
-    toSave.put(QUOTES_PROPERTY, this.quotes);
-    toSave.put(SPORTS_PROPERTY, this.sports);
-    toSave.put(TAGS_PROPERTY, this.tags);
-    toSave.put(TURNOFFS_PROPERTY, this.turnOffs);
-    toSave.put(TURNONS_PROPERTY, this.turnOns);
-    toSave.put(TVSHOWS_PROPERTY, this.tvShows);
-
-    for (PersonPropertyDb pp : properties) {
-      List<String> l = toSave.get(pp.type);
-      if (l != null) {
-        l.add(pp.getValue());
-      }
-    }
-
-    this.lookingFor = Lists.newArrayList();
-    for (String lf : lookingFor) {
-      this.lookingFor.add(new EnumDb<LookingFor>(LookingFor.valueOf(lf)));
-    }
-
   }
 
   /*
@@ -1278,7 +1338,7 @@
    * @see org.apache.shindig.social.opensocial.model.Person#getDisplayName()
    */
   public String getDisplayName() {
-    return displayName;
+    return firstName+" "+lastName;
   }
 
   /*
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/eclipselink/Bootstrap.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/eclipselink/Bootstrap.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/eclipselink/Bootstrap.java	(working copy)
@@ -107,12 +107,19 @@
     // Ensure that no server-platform is configured
     properties.put(TARGET_SERVER, TargetServer.None);
 
-    properties.put(PersistenceUnitProperties.DDL_GENERATION, PersistenceUnitProperties.CREATE_ONLY);
+    // TODO: this should be taken from persistence.xml
+    properties.put(PersistenceUnitProperties.DDL_GENERATION, "none");
     properties.put(PersistenceUnitProperties.DROP_JDBC_DDL_FILE, "drop.sql");
     properties.put(PersistenceUnitProperties.CREATE_JDBC_DDL_FILE, "create.sql");
-    properties.put(PersistenceUnitProperties.DDL_GENERATION_MODE,
-        PersistenceUnitProperties.DDL_BOTH_GENERATION);
+    properties.put(PersistenceUnitProperties.DDL_GENERATION_MODE,"database");
 
+    // The default shindig settings
+    // properties.put(PersistenceUnitProperties.DDL_GENERATION, PersistenceUnitProperties.CREATE_ONLY);
+    // properties.put(PersistenceUnitProperties.DROP_JDBC_DDL_FILE, "drop.sql");
+    // properties.put(PersistenceUnitProperties.CREATE_JDBC_DDL_FILE, "create.sql");
+    // properties.put(PersistenceUnitProperties.DDL_GENERATION_MODE,
+    //     PersistenceUnitProperties.DDL_BOTH_GENERATION);
+
     // properties.put(PersistenceUnitProperties.SESSION_CUSTOMIZER,
     // EnableIntegrityChecker.class.getName());
 
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/NameDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/NameDb.java	(revision 1162941)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/NameDb.java	(working copy)
@@ -32,7 +32,9 @@
 import javax.persistence.OneToMany;
 import javax.persistence.Table;
 import javax.persistence.Version;
+import javax.persistence.Transient;
 
+
 import java.util.List;
 
 /**
@@ -71,7 +73,8 @@
    * A list of people who shared this name, relationship is specified by the name property on the
    * Person Object.
    */
-  @OneToMany(targetEntity = PersonDb.class, mappedBy = "name")
+  // @OneToMany(targetEntity = PersonDb.class, mappedBy = "name")
+  @Transient
   private List<Person> persons;
 
   /**
Index: java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/MoodleContextDb.java
===================================================================
--- java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/MoodleContextDb.java	(revision 0)
+++ java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/MoodleContextDb.java	(revision 0)
@@ -0,0 +1,182 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.apache.shindig.social.opensocial.jpa;
+
+import static javax.persistence.CascadeType.ALL;
+import static javax.persistence.CascadeType.MERGE;
+import static javax.persistence.CascadeType.PERSIST;
+import static javax.persistence.CascadeType.REFRESH;
+import static javax.persistence.GenerationType.IDENTITY;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
+import org.apache.shindig.social.opensocial.jpa.api.DbObject;
+import org.apache.shindig.social.opensocial.jpa.api.FilterCapability;
+import org.apache.shindig.social.opensocial.jpa.api.FilterSpecification;
+import org.apache.shindig.protocol.model.Enum;
+import org.apache.shindig.protocol.model.FilterOperation;
+import org.apache.shindig.social.opensocial.model.Account;
+import org.apache.shindig.social.opensocial.model.Address;
+import org.apache.shindig.social.opensocial.model.BodyType;
+import org.apache.shindig.social.opensocial.model.Drinker;
+import org.apache.shindig.social.opensocial.model.ListField;
+import org.apache.shindig.social.opensocial.model.LookingFor;
+import org.apache.shindig.social.opensocial.model.Name;
+import org.apache.shindig.social.opensocial.model.NetworkPresence;
+import org.apache.shindig.social.opensocial.model.Organization;
+import org.apache.shindig.social.opensocial.model.Person;
+import org.apache.shindig.social.opensocial.model.Application;
+import org.apache.shindig.social.opensocial.model.Smoker;
+import org.apache.shindig.social.opensocial.model.Url;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.persistence.Basic;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.JoinTable;
+import javax.persistence.ManyToMany;
+import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
+import javax.persistence.OneToMany;
+import javax.persistence.PostLoad;
+import javax.persistence.PrePersist;
+import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+import javax.persistence.Transient;
+import javax.persistence.Version;
+
+/**
+ * Default Implementation of the Person object in the org.apache.shindig.social.opensocial.jpa.
+ */
+@Entity
+@Table(name = "mdl_context")
+public class MoodleContextDb implements DbObject {
+  
+  // 3 is owner in Graaasp
+  public static final String JPQL_OWNERS_BY_SPACE = "select p.userId from MoodleContextDb p where p.status = 'joined' and p.rightType = '3' and p.itemType = 'Space'";
+
+  /**
+   * The internal object ID used for references to this object. Should be generated by the
+   * underlying storage mechanism
+   */
+  @Id
+  @GeneratedValue(strategy = IDENTITY)
+  @Column(name = "id")
+  private long objectId;
+  
+  /**
+   * The internal itemId and itemType used for references to the item of a widget.
+   */
+  @Basic
+  @Column(name = "instanceid", length = 255)
+  private String instanceId;
+  
+  /**
+   *
+   */
+  @Basic
+  @Column(name = "id", length = 255, insertable = false, updatable = false)
+  protected String id;
+
+  // Note: Not in the opensocial js person object directly
+  @Transient
+  private boolean isOwner = false;
+
+  public MoodleContextDb() {
+  }
+
+  public String getInstanceId() {
+    return instanceId;
+  }
+
+  public void setInstanceId(String instanceId) {
+    this.instanceId = instanceId;
+  }                               
+
+    
+  public String getId() {
+    return id;
+  }
+
+  public void setId(String id) {
+    this.id = id;
+  }
+
+  public boolean getIsOwner() {
+    return isOwner;
+  }
+
+  public void setIsOwner(boolean isOwner) {
+    this.isOwner = isOwner;
+  }
+
+  // Proxied fields
+
+
+
+  private <T extends ListField> T getListFieldWithType(String type, List<T> list) {
+    if (list != null) {
+      for (T url : list) {
+        if (type.equalsIgnoreCase(url.getType())) {
+          return url;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private <T extends ListField> List<T> addListField(T field, List<T> list) {
+    if (list == null) {
+      list = Lists.newArrayList();
+    }
+    list.add(field);
+    return list;
+  }
+
+  /**
+   * @return the objectId
+   */
+  public long getObjectId() {
+    return Long.parseLong(id);
+  }
+
+  @PrePersist
+  public void populateDbFields() {
+
+
+  }
+
+  @PostLoad
+  public void loadTransientFields() {
+
+
+  }
+
+}
Index: java/samples/src/main/resources/META-INF/orm.xml
===================================================================
--- java/samples/src/main/resources/META-INF/orm.xml	(revision 1162941)
+++ java/samples/src/main/resources/META-INF/orm.xml	(working copy)
@@ -82,4 +82,14 @@
   </entity>
   <entity class="org.apache.shindig.social.opensocial.jpa.ApplicationDataMapValueDb">
   </entity>
+  <entity class="org.apache.shindig.social.opensocial.jpa.SpaceDb">
+  </entity>
+  <entity class="org.apache.shindig.social.opensocial.jpa.DocumentDb">
+  </entity>
+  <entity class="org.apache.shindig.social.opensocial.jpa.MoodleContextDb">
+  </entity>
+  <entity class="org.apache.shindig.social.opensocial.jpa.AppdataDb">
+  </entity>
+  <entity class="org.apache.shindig.social.opensocial.jpa.PermissionDb">
+  </entity>
 </entity-mappings>
Index: java/samples/src/main/resources/socialjpa.properties
===================================================================
--- java/samples/src/main/resources/socialjpa.properties	(revision 1162941)
+++ java/samples/src/main/resources/socialjpa.properties	(working copy)
@@ -15,12 +15,12 @@
 # specific language governing permissions and limitations
 # under the License.
 
-db.driver=org.apache.derby.jdbc.EmbeddedDriver
-db.url=jdbc:derby:target/testdb;create=true
-db.user=sa
-db.password=
+db.driver=com.mysql.jdbc.Driver
+db.url=jdbc:mysql://localhost:3306/moodle
+db.user=shindig
+db.password=shindig
 db.write.min=1
 db.read.min=1
 jpa.socialapi.unitname=default
-
+ 
 shindig.canonical.json.db=sampledata/canonicaldb.json
Index: java/samples/pom.xml
===================================================================
--- java/samples/pom.xml	(revision 1162941)
+++ java/samples/pom.xml	(working copy)
@@ -79,7 +79,14 @@
       </plugin>
     </plugins>
   </build>
-  <dependencies>
+  <dependencies>    
+    <!-- add a driver for mysql -->
+    <dependency>
+      <groupId>mysql</groupId>
+      <artifactId>mysql-connector-java</artifactId>
+      <version>5.1.6</version>
+    </dependency>
+    
     <!-- project dependencies -->
     <dependency>
       <groupId>org.apache.shindig</groupId>
Index: java/server/src/main/webapp/WEB-INF/web.xml
===================================================================
--- java/server/src/main/webapp/WEB-INF/web.xml	(revision 1162941)
+++ java/server/src/main/webapp/WEB-INF/web.xml	(working copy)
@@ -33,13 +33,9 @@
       org.apache.shindig.common.PropertiesModule:
       org.apache.shindig.gadgets.DefaultGuiceModule:
       org.apache.shindig.social.core.config.SocialApiGuiceModule:
-      org.apache.shindig.social.sample.SampleModule:
+      org.apache.shindig.social.opensocial.jpa.spi.JPASocialModule:
       org.apache.shindig.gadgets.oauth.OAuthModule:
       org.apache.shindig.common.cache.ehcache.EhCacheModule:
-      org.apache.shindig.sample.shiro.ShiroGuiceModule:
-      org.apache.shindig.sample.container.SampleContainerGuiceModule:
-      org.apache.shindig.extras.ShindigExtrasGuiceModule:
-      org.apache.shindig.extras.as.ActivityStreamsGuiceModule
     </param-value>
   </context-param>
 
@@ -62,7 +58,7 @@
     	shindig.host=localhost
     	
     	aKey=/shindig/gadgets/proxy?container=default&amp;url=
-    	shindig.port=
+    	shindig.port=8080
     	
      </param-value>
   </context-param>  
Index: java/server/pom.xml
===================================================================
--- java/server/pom.xml	(revision 1162941)
+++ java/server/pom.xml	(working copy)
@@ -125,6 +125,11 @@
       <groupId>org.apache.shindig</groupId>
       <artifactId>shindig-extras</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.apache.shindig</groupId>
+      <artifactId>shindig-samples</artifactId>
+    </dependency>
+    
 
     <!-- external dependencies -->
     <dependency>
Index: java/common/conf/shindig.properties
===================================================================
--- java/common/conf/shindig.properties	(revision 1162941)
+++ java/common/conf/shindig.properties	(working copy)
@@ -31,8 +31,8 @@
 
 ### Outbound OAuth support
 shindig.signing.state-key=
-shindig.signing.key-name=
-shindig.signing.key-file=
+shindig.signing.key-name=mytestkey
+shindig.signing.key-file=/Library/WebServer/Documents/shindig_moodle_2.0/ssl_keys/oauthkey.pem
 shindig.signing.global-callback-url=http://localhost:8080/gadgets/oauthcallback
 shindig.signing.enable-signed-callbacks=true
 
Index: java/common/src/main/java/org/apache/shindig/auth/BasicSecurityTokenCodec.java
===================================================================
--- java/common/src/main/java/org/apache/shindig/auth/BasicSecurityTokenCodec.java	(revision 1162941)
+++ java/common/src/main/java/org/apache/shindig/auth/BasicSecurityTokenCodec.java	(working copy)
@@ -78,8 +78,10 @@
 
     try {
       String[] tokens = StringUtils.split(token, ':');
-      if (tokens.length != TOKEN_COUNT) {
+      if (tokens.length < TOKEN_COUNT) {
         throw new SecurityTokenException("Malformed security token");
+      }else{
+    	  tokens = this.parseToken(tokens);
       }
 
       return new BasicSecurityToken(
@@ -104,4 +106,26 @@
    */
   public BasicSecurityTokenCodec() {
   }
+  /**
+   * Parses the security token
+   */
+  public String[] parseToken(String[] tokens) {
+    int url_number = tokens.length-6;
+    String[] output = new String[TOKEN_COUNT];
+    //get array elements corresponding to broken url - http://host:port/gadget.xml -> ["http","//host","port/gadget.xml"]
+    
+    String[] url_array = new String[url_number];
+    //copy first part (before url)
+    System.arraycopy(tokens,0,output,0,4);
+    //build url
+    System.arraycopy(tokens, 4, url_array, 0, url_number);
+    String url = Joiner.on(":").join(url_array);
+    //copy url
+    output[4] = url;
+    //copy last part (after url)
+    System.arraycopy(tokens,(4+url_number),output,5,2);
+    
+    return output;   
+  }
+  
 }
Index: pom.xml
===================================================================
--- pom.xml	(revision 1162941)
+++ pom.xml	(working copy)
@@ -431,6 +431,7 @@
         <module>java/gadgets</module>
         <module>java/social-api</module>
         <module>java/server</module>
+        <module>java/samples</module>
         <module>extras</module>
       </modules>
     </profile>
@@ -494,6 +495,7 @@
           <artifactId>shindig-extras</artifactId>
           <version>${project.version}</version>
         </dependency>
+        
         <!-- external dependencies -->
       </dependencies>
 
@@ -1390,6 +1392,11 @@
       </dependency>
       <dependency>
         <groupId>org.apache.shindig</groupId>
+        <artifactId>shindig-samples</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.apache.shindig</groupId>
         <artifactId>shindig-common</artifactId>
         <version>${project.version}</version>
         <type>test-jar</type>
Index: features/src/main/javascript/features/shindig.container/shindig-container.js
===================================================================
--- features/src/main/javascript/features/shindig.container/shindig-container.js	(revision 1162941)
+++ features/src/main/javascript/features/shindig.container/shindig-container.js	(working copy)
@@ -648,6 +648,17 @@
   // Get the gadget metadata and check if the gadget requires the 'pubsub-2'
   // feature.  If so, then we use OpenAjax Hub in order to create and manage
   // the iframe.  Otherwise, we create the iframe ourselves.
+  
+  // ***********************
+  // TODO: Evgeny's extension to avoid buggy metadata call
+  var gadget = this;
+  var subClass = shindig.IfrGadget;
+  for (var name in subClass) if (subClass.hasOwnProperty(name)) {
+    gadget[name] = subClass[name];
+  }
+  return;
+  // ***********************
+  
   var request = {
     context: {
       country: "default",
